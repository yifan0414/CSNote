---
创建时间: 2024-08-23 22:11
难度: 普及/提高-
URL: https://www.luogu.com.cn/problem/P1331
tags:
  - DFS
intro:
---
# 海战

## 题目背景

在峰会期间，武装部队得处于高度戒备。警察将监视每一条大街，军队将保卫建筑物，领空将布满了 F-2003 飞机。

此外，巡洋船只和舰队将被派去保护海岸线。不幸的是，因为种种原因，国防海军部仅有很少的几位军官能指挥大型海战。因此，他们培养了一些新海军指挥官。军官们选择了“海战”游戏来帮助他们学习。

## 题目描述

在一个方形的盘上，放置了固定数量和形状的船只，每只船却不能碰到其它的船。在本题中，我们认为船是方形的，所有的船只都是由图形组成的方形。

求出该棋盘上放置的船只的总数。

## 输入格式

第一行为两个整数 $R$ 和 $C$，用空格隔开，分别表示游戏棋盘的行数和列数。

接下来 $R$ 行，每行 $C$ 个字符，为 `#` 或 `.`。`#` 表示船只的一部分，`.` 表示水。

## 输出格式

一行一个字符串，如果船的位置放得正确（即棋盘上只存在相互之间不能接触的方形，如果两个 `#` 号上下相邻或左右相邻却分属两艘不同的船只，则称这两艘船相互接触了）。就输出 `There are S ships.`，$S$ 表示船只的数量。否则输出 `Bad placement.`。

## 样例 #1

### 样例输入 #1

```
6 8
.....#.#
##.....#
##.....#
.......#
#......#
#..#...#
```

### 样例输出 #1

```
There are 5 ships.
```

## 提示

对于 $100\%$ 的数据，$1 \leqslant R,C \leqslant 1000$。

## 分析

这道题与普通的寻找连通块的数量的题有所不同，**要求我们检测连通块是否是方形**。

>[!tip] 
> 我们可以在 `dfs` 函数中记录当前连通块的数量，**然后贪心的找到该连通块的左上角和右下角**。比较这两个值是否相同，如果相同则为方形，否则不是方形
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int r, c;
vector<string> v(1005);
int f[1005][1005];

void dfs(int x, int y, int& all) {
    if (x < 0 || x >= r || y < 0 || y >= c) return ;
    if (f[x][y] == 1) return ;
    if (v[x][y] == '.') return ;

    f[x][y] = 1;
    all++;
    dfs(x + 1, y, all);
    dfs(x - 1, y, all);
    dfs(x, y + 1, all);
    dfs(x, y - 1, all);
}

int main() {
    cin >> r >> c;

    for (int i = 0; i < r; i++) {
        cin >> v[i];
    }

    int cnt = 0;
    for (int i = 0; i < r; i++) {
        for (int j = 0; j < c; j++) {
            if (v[i][j] == '.') continue;
            if (f[i][j] == 1) continue;
            int all = 0;
            dfs(i, j, all);

            int i2 = i, j2 = j;
            while (i2 + 1 < r && v[i2 + 1][j2] == '#') i2++;
            while (j2 + 1 < c && v[i2][j2 + 1] == '#') j2++;

            if ((i2 - i + 1) * (j2 - j + 1) != all) {
                cout << "Bad placement." << endl;
                return 0;
            }
            cnt++;
        }
    }

    printf("There are %d ships.", cnt);
}


```


分析时间复杂度时，我们主要考虑算法在最坏情况下需要处理的状态数和每个状态的处理时间。

### DFS 方法的时间复杂度

在原始的 DFS 实现中，时间复杂度主要取决于访问的节点数以及递归的深度。

1. **访问的节点数**：DFS 会访问所有能到达的格子。在最坏情况下，整个迷宫的每个格子都可能被访问一次，所以最多会访问 $O(n \times m)$ 个格子。
  
2. **递归深度**：对于每个格子，最多会进行 4 次递归调用（上下左右各一次）。因此，递归的深度与移动次数 `x` 和 `y` 有关。在最坏情况下，DFS 的深度可能达到 $O(\min(x, y, n \times m))$。

3. **时间复杂度**：综合考虑后，DFS 的时间复杂度可以近似为 $O(n \times m)$，因为在最坏情况下，每个格子只会被访问一次。但由于使用了递归，实际复杂度还受到栈空间限制，可能会导致栈溢出，尤其当 `x` 和 `y` 非常大时。

### BFS 方法的时间复杂度

BFS 的时间复杂度分析较为直观：

1. **访问的节点数**：和 DFS 类似，BFS 会访问所有能够到达的格子，在最坏情况下需要访问 $O(n \times m)$ 个格子。

2. **每个节点的处理时间**：对于每个格子，BFS 会检查上下左右四个方向，所以每个节点的处理时间是常数级别的 $O(1)$。

3. **队列操作**：每个节点最多被加入队列和出队列一次，因此队列操作的总时间复杂度为 $O(n \times m)$。

4. **时间复杂度**：总体来说，BFS 的时间复杂度也是 $O(n \times m)$，但 BFS 不涉及递归，栈深度不会受限制，不容易出现栈溢出问题。

### 比较

- **DFS**: 在理论上，DFS 的时间复杂度是 $O(n \times m)$，但由于递归深度可能较大（尤其是 `x` 和 `y` 很大时），在实际运行中可能会受到栈深度的限制。

- **BFS**: BFS 也是 $O(n \times m)$，但它的实际运行更稳定，因为 BFS 是通过队列进行层次遍历，避免了递归带来的栈溢出问题。

### 总结

两种方法的时间复杂度都是 $O(n \times m)$，但 BFS 更适合这种带有步数限制的问题，尤其当 `x` 和 `y` 很大时，DFS 可能会遇到实际运行中的问题（如栈溢出），而 BFS 则更加稳定和高效。