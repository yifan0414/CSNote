---
创建时间: 2024-05-27 23:19
难度: ⭐️⭐️⭐️
URL: https://leetcode.cn/problems/Gu0c2T/description/
tags:
  - 动态规划
  - 线段树
---
## 题目

一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组 `nums` ，请计算 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**示例 1：**

**输入：** $nums = [1,2,3,1]$
**输出：** 4
**解释：** 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。

**示例 2：**

**输入：** $nums = [2,7,9,3,1]$
**输出：** 12
**解释：** 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`




## 解法一 (动态规划)

这两个代码实现了经典的“打家劫舍”问题，尽管它们的实现方式不同，但它们都能正确地解决问题。

### 第一个实现

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n + 1, 0);

        int res = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i - 1; j++) {
                dp[i] = max(dp[i], dp[j]);
            }
            dp[i] += nums[i];
            res = max(res, dp[i]);
        }
        return res;
    }
};
```

#### 解释

1. **状态定义**：
   - `dp[i]` 表示必须偷第 $i$ 个房子时的最大值

2. **状态转移**：
   - 对于每个房子 `i`，它的最大值 `dp[i]` 可以通过之前所有不相邻的房子的最大值 `dp[j]` 转移过来。
   - 更新 `dp[i]` 为 `max(dp[i], dp[j])`，然后加上当前房子的金额 `nums[i]`。

3. **时间复杂度**：
   - 由于嵌套循环，时间复杂度为 $O (n^2)$。

### 第二个实现

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.empty()) {
            return 0;
        }
        int size = nums.size();
        if (size == 1) {
            return nums[0];
        }
        vector<int> dp = vector<int>(size, 0);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < size; i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[size - 1];
    }
};
```

#### 解释

1. **状态定义**：
   - `dp[i]` 表示偷到第 `i` 个房子时能获得的最大金额。（可选择偷或者不偷）

2. **状态转移**：
   - 对于每个房子 `i`，有两个选择：
     - 偷第 `i` 个房子，则前一个房子不能偷，最大金额为 `dp[i - 2] + nums[i]`。
     - 不偷第 `i` 个房子，最大金额为 `dp[i - 1]`。
   - 取两者的最大值 `dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])`。

3. **时间复杂度**：
   - 单循环，时间复杂度为 \(O (n)\)。

### 为什么这两个实现都能得到正确结果？

这两个实现都遵循了动态规划的基本思路，即通过维护一个数组 `dp` 来存储当前子问题的最优解，从而构建出整个问题的最优解。

- **第一个实现**通过遍历所有可能的前一个不相邻的房子来更新当前房子的最大值。
- **第二个实现**则是更直接地利用了之前两个状态的最优解来更新当前房子的最大值。

尽管第一个实现的时间复杂度较高，但它仍然正确地维护了状态转移关系，因此能够得到正确的结果。第二个实现则是优化后的版本，利用了更少的状态转移，时间复杂度更低，更为高效。

### 总结

两个实现都正确地解决了问题，它们的区别在于时间复杂度和实现方式。第二个实现更为高效，通常是推荐的实现方式。

## 解法二（线段树）

主要考虑**分治**的做法