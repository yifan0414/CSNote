---
创建时间: 2024-08-21 16:43
难度: ⭐️
URL: 
tags:
  - "#动态规划"
  - "#dfs"
intro: 二叉树，动态规划
---

> 本题正解为**动态规划**做法，但也可以用来练习 $DFS$，使用搜索算法时只需通过样例即可

## 题目描述

阿福是一名经验丰富的大盗。趁着月黑风高，阿福打算今晚洗劫一条街上的店铺。

这条街上一共有 $N$ 家店铺，每家店中都有一些现金。阿福事先调查得知，只有当他同时洗劫了两家相邻的店铺时，街上的报警系统才会启动，然后警察就会蜂拥而至。

作为一向谨慎作案的大盗，阿福不愿意冒着被警察追捕的风险行窃。他想知道，在不惊动警察的情况下，他今晚最多可以得到多少现金？

## 输入

输入的第一行是一个整数 $T(T≤50)$ ，表示一共有 $T$ 组数据。

接下来的每组数据，第一行是一个整数 $N(1\leqslant N \leqslant 100,000)$，表示一共有 $N$ 家店铺。第二行是 $N$ 个被空格分开的正整数，表示每一家店铺中的现金数量。每家店铺中的现金数量均不超过 $1000$。

## 输出

对于每组数据，输出一行。该行包含一个整数，表示阿福在不惊动警察的情况下**最多**可以得到的现金数量。

## 样例

```input1
2
3
1 8 2
4
10 7 6 14
```

```output1
8
24
```

## 提示

对于第一组样例，阿福选择第 $2$ 家店铺行窃，获得的现金数量为 $8$。

对于第二组样例，阿福选择第 $1$ 和 $4$ 家店铺行窃，获得的现金数量为 $10+14=24$。

## 代码

### 1 常规 DFS

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, maxn;
int f[100010];

int dfs(int x) {
    if (x >= n) return 0;
    return max(dfs(x + 2) + f[x], dfs(x + 1));
}


int main() {
    int t;
    cin >> t;

    while (t--) {
        maxn = 0;
        cin >> n;
        for (int i = 0; i < n; i++) {
            cin >> f[i];
        }
        cout << dfs(0) << endl;
    }
    return 0;
}
```

### 2 记忆化搜索

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, maxn;
int f[100010];
int dp[100010]; // 用于存储在每个位置 `x` 处的最大值

// 记忆化搜索的dfs函数
int dfs(int x) {
    // 如果已经计算过这个位置，直接返回存储的值
    if (dp[x] != -1) return dp[x];

    // 递归边界：当 `x` 超出数组范围时，返回0
    if (x >= n) return 0;

    // 选择跳过当前位置，去尝试下一个位置
    int take = f[x] + dfs(x + 2); // 选择当前位置，跳过下一个
    int skip = dfs(x + 1); // 跳过当前位置

    // 存储当前点的最大值
    dp[x] = max(take, skip);
    
    return dp[x];
}

int main() {
    int t;
    cin >> t;

    while (t--) {
        cin >> n;
        for (int i = 0; i < n; i++) {
            cin >> f[i];
        }
        
        // 初始化dp数组为-1，表示还未计算过
        memset(dp, -1, sizeof(dp));
        
        // 从第0个位置开始搜索
        maxn = dfs(0);
        cout << maxn << endl;
    }

    return 0;
}
```

```ad-note
title: 记忆化搜索解析
collapse: 

在记忆化搜索中，确定 `dp[x]` 的第一次计算是最优解的原因在于递归和动态规划的核心原理：**自底向上计算**和**最优子结构**。

### 最优子结构性质
最优子结构性质指的是，问题的最优解可以通过其子问题的最优解来构建。在这个问题中，`dp[x]` 表示从位置 `x` 开始的最大累积和，这个值的计算依赖于后续的 `dp[x+1]` 和 `dp[x+2]`。

### 递归过程中的决策
对于每个位置 `x`，我们有两种选择：
1. **选择当前元素** `f[x]`，然后跳过下一个元素，继续计算从 `x + 2` 开始的最优解。
2. **跳过当前元素** `f[x]`，直接计算从 `x + 1` 开始的最优解。

这两种选择的最大值就是从位置 `x` 开始的最优解，即 `dp[x]`。

### 确定最优解的过程
- **第一次计算 `dp[x]`** 是基于从 `x` 开始的所有可能路径的最优决策。这意味着在 `dfs(x)` 中，我们尝试了从 `x` 开始的所有可能路径，并选择了其中最大的一条路径。 
- 因为递归的过程本质上是在求解从当前位置 `x` 开始的最优解，并且在每次递归中，函数总是选择当前状态的最优路径，所以第一次计算 `dp[x]` 时，已经包含了从 `x` 开始所有可能路径的最优决策。

### 剪枝与记忆化
- 一旦 `dp[x]` 计算出来，就表示从位置 `x` 开始的最优解已经被确定。由于动态规划的**重叠子问题**性质，未来在任何其他递归调用中，再次遇到 `x` 时，直接使用 `dp[x]` 的值，而无需重新计算。这避免了重复计算，也确保了每次使用 `dp[x]` 时都是最优解。

### 例子
假设我们有一个数组 `f = [3, 2, 5, 10, 7]`，并且我们要计算从位置 `x = 0` 开始的最大和：
- 在 `dfs(0)` 中，我们会计算 `dp[0]`。这个计算过程会递归地尝试从 `x = 2` 和 `x = 1` 开始的所有可能路径，并选择最大值。这使得 `dp[0]` 代表了从 `0` 开始的所有可能路径的最大和。
- 因此，当 `dp[0]` 被首次计算时，它已经是最优的，并且是基于子问题的最优解构建的。

### 总结
记忆化搜索的递归过程确保了 `dp[x]` 的值是通过考虑从 `x` 开始的所有可能路径并选择最优路径得出的。由于每个 `dp[x]` 的计算都涉及到对子问题的最优解的合并，首次计算的 `dp[x]` 自然就是最优解。
```

### 3 动态规划

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
int f[100010];
int dp[100010];  // dp[i]表示前i个数的最大和

int main() {
    int t;
    cin >> t;

    while (t--) {
        cin >> n;
        for (int i = 0; i < n; i++) {
            cin >> f[i];
        }

        // 边界条件
        if (n == 0) {
            cout << 0 << endl;
            continue;
        }

        dp[0] = 0;  // 前0个数的最大和为0
        dp[1] = f[0];  // 前1个数的最大和为f[0]

        for (int i = 2; i <= n; i++) {
            dp[i] = max(dp[i-1], dp[i-2] + f[i-1]);
        }

        cout << dp[n] << endl;
    }
    return 0;
}
```