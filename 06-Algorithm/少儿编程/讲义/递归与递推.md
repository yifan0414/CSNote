## 一、转进制

用**递归算法**将一个十进制数 $X$ 转换成任意进制数 $M（M≤16）$ 。

#### 输入

一行两个数，第一个十进制数 $X$，第二个为进制 $M$。
#### 输出

输出结果。

#### 输入数据

将十进制 31 转化为十六进制数

```
31 16
```

#### 输出数据

```
1F
```

### 思路

```cpp
#include <iostream>
using namespace std;

void f(int n, int k) {
  if (n != 0) {
    f(n / k, k); // 我们最后才要输出个位，所以先禁入递归函数
    if (n % k >= 0 and n % k <= 9) cout << (char) ((n % k) + '0');
    else cout << (char) ('A' + (n % k - 10));
  }
}

int main() {
  int n, k;
  cin >> n >> k;

  f(n, k);
}
```



## 二、弹球距离

>[!attention] 使用**递归**完成本题

设有一个球从高度为 **h** 米的地方落下，碰到地面后又弹到高度为原来 **p** 倍的位置，然后又落下，再弹起，再落下…。请编写函数求初始高度为 **h** 的球下落后到基本停下来（高度小于给定阈值 $0.001$）时在空中所经过的路程总和。

#### 函数接口定义：

```cpp
double dist( double h, double p );
```

其中 `h` 是球的初始高度，`p` 是球弹起高度与弹起前落下高度的比值；函数 `dist` 要返回球下落后到基本停下来时在空中所经过的路程总和。注意：当弹起的高度小于裁判程序定义的常数 $0.001$ 时，弹起的距离不计算在内。

#### 输入格式

两个浮点数，`h` 和 `p`

#### 输出格式

路程总和，保留 $6$ 位小数

#### 输入数据 1

```input1
1.0 0.4
```

#### 输出数据 1

```output1
2.331149
```
#### 输入数据 2

```input2
2.5 0.5
```
#### 输出数据 2

```output2
7.497559
```

### 思路

![弹球距离](https://picture-suyifan.oss-cn-shenzhen.aliyuncs.com/%25E5%25BC%25B9%25E7%2590%2583%25E8%25B7%259D%25E7%25A6%25BB.svg)

我们的目的是通过递归计算出弹球从高度 $h$ 下落，直到弹起的高度小于 $0.001$，因此我们可以写出递归表达式
$$
dist(h,p)=h+h*p+dist(h*p,p)
$$
还需要考虑递归出口，也就是在当前高度为 $h$ 时，如果 $h*p<0.001$，则直接返回 $h$。

## 三、过河卒

棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。

棋盘用坐标表示，$A$ 点 $(0, 0)$、$B$ 点 $(n, m)$，同样马的位置坐标是需要给出的。

<img src=" https://cdn.luogu.com.cn/upload/image_hosting/ipmwl52i.png" alt="img" style="zoom: 40%;" />

现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。

#### 输入格式
一行四个正整数，分别表示 $B$ 点坐标和马的坐标。

#### 输出格式
一个整数，表示所有的路径条数。

#### 输入数据
```input1
6 6 3 3
```
#### 输出数据
```output1
6
```

#### 数据范围
对于 $100 \%$ 的数据，$1 \le n, m \le 20$，$0 \le$ 马的坐标 $\le 20$。



## 思路

对于位置 $(x,y)$，其只能由 $(x-1,y)$ 或者 $(x, y-1)$ 移动过来，因此，如果要用 $f[x][y]$ 表示从 $(0,0)$ 点到 $(x, y)$ 点的路径条数，那么
$$
f[x][y] = f[x-1][y]+f[x][y-1]
$$
又因为题目要求**不能走**马所在的点和所有跳跃一步可达的点，我们只需要检测出来然后跳过即可

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;
int n, m, hx, hy;

long long f[22][22];

int dx[] = {-2, -1, +1, +2, +2, +1, -1, -2};
int dy[] = {-1, -2, -2, -1, +1, +2, +2, +1};
bool check(int x, int y) {
    if (x == hx && y == hy) return false;
    for (int i = 0; i < 8; i++) {
        if (x == hx + dx[i] && y == hy + dy[i]) return false;
    }
    return true;
}
int main() {
    cin >> n >> m >> hx >> hy;
    hx++, hy++;
    f[1][1] = 1;
    for (int i = 1; i <= n + 1; i++) {
        for (int j = 1; j <= m + 1; j++) {
            if (i == 1 && j == 1) continue;
            if (!check(i, j)) continue;
            f[i][j] = f[i-1][j] + f[i][j-1];
        }
    }
    cout << f[n + 1][m + 1] << endl;
    return 0;
}
```



## 四、数的计算

给出正整数 $n$，要求按如下方式构造数列：

1. 只有一个数字 $n$ 的数列是一个合法的数列。
2. 在一个合法的数列的末尾加入一个正整数，但是这个正整数不能超过该数列最后一项的一半，可以得到一个新的合法数列。

请你求出，一共有多少个合法的数列。两个合法数列 $a, b$ 不同当且仅当两数列长度不同或存在一个正整数 $i \leq |a|$，使得 $a_i \neq b_i$。

#### 输入格式

输入只有一行一个整数，表示 $n$。

#### 输出格式

输出一行一个整数，表示合法的数列个数。

#### 输入数据 1

```
6
```

#### 输出数据 1

```
6
```

### 提示

#### 样例 1 解释

满足条件的数列为：

- $6$
- $6, 1$
- $6, 2$
- $6, 3$
- $6, 2, 1$
- $6, 3, 1$

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 10^3$。

### 思路

我们可以列举几个数列观察，

| 1    | 2     | 3     | 4     | 5       | 6       |
| ---- | ----- | ----- | ----- | ------- | ------- |
| $1$  | $2$   | $3$   | $4$   | $5$     | $6$     |
|      | $2,1$ | $3,1$ | $4,1$ | $5,1$   | $6,1$   |
|      |       |       | $4,2$ | $5,2$   | $6,2$   |
|      |       |       |       | $5,2,1$ | $6,2,1$ |
|      |       |       |       |         | $6,3$   |
|      |       |       |       |         | $6,3,1$ |



我们可以看出，对于一个数 $x$，他的数列，可以由 $[1..\dfrac{x}{2}]$ 的子数列组成，只需要在这些子数列的前面加上 $x$ 就行。

例如，$6$ 可以由 $1$ 的子数列，$2$ 的子序列，$3$ 的子序列组成。得到下面的公式。
$$
f[x]=1 + \sum_{i=1}^{x/2}f[i]
$$

## 五、栈

#### 题目背景

栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。

栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。

栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。

#### 题目描述

<img src=" https://cdn.luogu.com.cn/upload/image_hosting/5qxy9fz2.png" style="zoom: 33%;" />

宁宁考虑的是这样一个问题：一个操作数序列，$1,2,\ldots ,n$（图示为 1 到 3 的情况），栈 A 的深度大于 $n$。

现在可以进行两种操作，

1. 将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）
2. 将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）

使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 `1 2 3` 生成序列 `2 3 1` 的过程。

<img src=" https://cdn.luogu.com.cn/upload/image_hosting/8uwv2pa2.png" style="zoom: 50%;" />

（原始状态如上图所示）

你的程序将对给定的 $n$，计算并输出由操作数序列 $1,2,\ldots,n$ 经过操作可能得到的输出序列的总数。

#### 输入格式

输入文件只含一个整数 $n$（$1 \leq n \leq 18$）。

#### 输出格式

输出文件只有一行，即可能输出序列的总数目。

#### 样例输入 #1

```
3
```

#### 样例输出 #1

```
5
```

### 思路

我们考虑序列 $1,2,\ldots,n$，假设最后出栈的是 $10$，也就是 $1,2,...,9,10,11,...,n$ 中，$1,2,...,9$ 必须在 $10$ 进栈之前就得出栈。（因为这样才能满足**后进先出**原则，如果 $1,2,\ldots,9$ 中有一个没出栈，$10$ 就进栈了，那么最后一个出栈的数必然不可能是 $10$，矛盾。）同样的，$11,12,..n$ 也必须先出栈。

所以假设 $f[n]$ 代表 $n$ 个数输出序列的总数目，$g[i]$ 代表序列 $1,2,...,n$ 中最后一个出栈的数是 $i$ 的输出序列总数目。对于 $g[10]$，$1,2,...,9$ 输出序列的总数目是 $f[9]$，$11,12,...,n$ 输出序列的总数目是 $f[n- 10]$，故
$$
g[10] = f[9] * f[n - 10]
$$
普遍情况
$$
g[x]=f[x-1]*f[n-x]
$$

> [!math] 分析 🎃
>
> 对于序列 $1,2,\ldots,n$，其出栈的总数目可以分为下面 $n$ 种情况
>
> - 最后一个出栈的是 $1$
> - 最后一个出栈的是 $2$
> - ...
> - 最后一个出栈的是 $n$ ​
>
> 对于 $f[10]$
> $$
> \begin{align}
> f[10] &= g[1]+g[2]+...+g[10] \\
> &= f[0] * f[9] + f[1] * f[8] + ..+f[9] * f[0]\\
> \end{align}
> $$

由上面可知

$$
\begin{align}
f[n] &= \sum_{i=1}^{n}g[i] \\
 &= g[1]+g[2]+ ..+g[n]\\
 &=f[0]*f[n-1]+f[1]*f[n-2] + .. + f[n-1]*f[0]\\
 &=\sum_{i=0}^{n-1}f[i]*f[n-1-i]\\
\end{align}
$$

