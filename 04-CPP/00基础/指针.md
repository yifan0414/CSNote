```ad-question
~~~cpp
ListNode* a = new ListNode(1);  // 创建一个新节点 a
ListNode* b = a;                // 将 b 指向 a
b = b->next;                    // 只改变 b 指针的指向，而不会影响 a
~~~
```

这是一个关于指针和对象关系的经典问题。理解这一点的关键是要区分“指针本身”与“指针所指向的对象”之间的区别。

### 1. **指针与对象的关系：**
- 在 C++ 中，指针（例如 `ListNode* a`）是一个**变量**，它保存了某个对象在内存中的地址。
- 对象（例如 `new ListNode(1)`）是实际存储数据的内存区域。
- 当我们将一个指针变量赋值给另一个指针变量时，**它们共享同一个地址**，指向同一个对象，但这两个指针变量本身是**独立的**。

### 2. **通过例子理解：**
```cpp
ListNode* a = new ListNode(1);  // 创建一个新节点对象，并让指针 a 指向它
ListNode* b = a;                // 将 b 指向 a 指向的同一个节点
b = b->next;                    // 将 b 指向下一个节点，而 a 仍然指向原节点
```

让我们用图示说明 `a` 和 `b` 的变化：

1. **初始化时：**
```cpp
ListNode* a = new ListNode(1);
ListNode* b = a;
```
这时的内存状态如下：

```
+---------+     +------------------+
| Pointer | --> | ListNode Object  |
|  a      |     | val = 1          |
+---------+     | next = nullptr   |
                +------------------+
                
+---------+
| Pointer |   // b 也指向同一个节点
|  b      |
+---------+
```

- `a` 和 `b` 都指向同一个节点（`val = 1`，`next = nullptr`），即 `b` 只是将 `a` 的地址拷贝给自己。
- 虽然它们指向同一个节点，但 `a` 和 `b` 作为指针变量是两个**不同的**实体。

2. **修改 `b` 的指向：**
```cpp
b = b->next;
```
这时 `b` 被修改为指向 `a` 指向节点的 `next` 节点（`b->next`），而 `a` 仍然保持指向原节点。状态如下：

```
+---------+     +------------------+
| Pointer | --> | ListNode Object  |
|  a      |     | val = 1          |
+---------+     | next = nullptr   |
                +------------------+
                
+---------+     
| Pointer |     // b 现在变成了 nullptr
|  b      |     
+---------+
```

- `a` 和 `b` 不再指向同一个节点。
- `a` 仍然指向最初的节点，而 `b` 因为 `b = b->next` 的操作，现在变成了 `nullptr`（假设 `a->next` 为 `nullptr`）。

### 3. **结合你提到的代码：**
在你提供的代码中：

```cpp
minx = lists[i];  // 让 minx 指向 lists[i] 指向的节点
minx = minx->next; // minx 前移到下一个节点，但 lists[i] 仍然指向原节点
```

- 当 `minx = lists[i];` 时，`minx` 和 `lists[i]` 都指向同一个节点，但 `minx` 是**局部变量**，`lists[i]` 是 `lists` 数组中的指针元素。
- 当你执行 `minx = minx->next;` 时，你只是**修改了 `minx` 本身的指向**，但 `lists[i]` 仍然保持原始指向。也就是说，`lists[i]` 的指向**没有任何变化**。

用图示表示这个过程：

1. **初始状态：**

假设 `lists[i]` 和 `minx` 都指向一个值为 `5` 的节点（该节点的 `next` 指向值为 `10` 的节点）：

```
lists[i]
   |
   v
+---------+     +------------------+     +------------------+
| Pointer | --> | ListNode Object  | --> | ListNode Object  |
| lists[i]|     | val = 5          |     | val = 10         |
+---------+     | next = ...       |     | next = ...       |
                +------------------+     +------------------+
                
minx
   |
   v
+---------+
| Pointer |
|  minx   |
+---------+
```

2. **执行 `minx = minx->next;` 后：**

```
lists[i]
   |
   v
+---------+     +------------------+     +------------------+
| Pointer | --> | ListNode Object  | --> | ListNode Object  |
| lists[i]|     | val = 5          |     | val = 10         |
+---------+     | next = ...       |     | next = ...       |
                +------------------+     +------------------+
                
minx
           |
           v
+---------+     +------------------+
| Pointer | --> | ListNode Object  |
|  minx   |     | val = 10         |
+---------+     | next = ...       |
                +------------------+
```

- `minx` 已经指向了下一个节点，但 `lists[i]` 仍然保持原始位置不变，指向值为 `5` 的节点。

### 4. **如何更新 `lists[i]`：**
你应该修改 `lists[i]` 自身的指向，而不是只修改 `minx` 的指向。

```cpp
lists[i] = lists[i]->next;
```

这样 `lists[i]` 才会移动到下一个节点。

### 5. **总结：**
`a` 和 `b` 作为指针变量是**独立的**，它们指向同一个节点时（即 `a = b`），它们共享同一个对象的地址。但当其中一个指针修改自己的指向时（如 `b = b->next`），它们就会指向不同的节点。

所以，即使 `minx = lists[i]`，`minx` 和 `lists[i]` 仍然是**两个独立的指针变量**。修改 `minx` 不会影响 `lists[i]`，必须显式地去修改 `lists[i]` 才能真正更新它指向的链表节点。