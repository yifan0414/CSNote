>[!question] 在一本C++的书里这样写到，使用\#include及头文件实现模块化是一个传统方法 ，它有明显的缺点。如果在101个翻译单元中 \#include header. h 这个 header. h会被编译器处理101次。这句话正确吗？

是的，这句话是正确的。在 C++ 中使用 `#include` 指令和头文件是实现代码模块化的传统方法。当你在多个源文件中包含同一个头文件时，每个源文件（或称为编译单元）都会单独处理这个头文件。因此，如果你在 101 个不同的源文件中都包含了 `header.h`，编译器会在每一个源文件的编译过程中单独处理这个头文件，导致 `header.h` 被处理 101 次。

这种重复处理可以导致几个问题：

1. **编译时间增长**：每个编译单元都需要处理头文件，这会显著增加整个项目的编译时间。
2. **代码冗余**：头文件中的代码在每个包含它的编译单元中都会被复制，增加了最终生成的二进制文件的大小。
3. **一致性问题**：如果头文件被修改，所有包含这个头文件的源文件都需要重新编译，这有时会引起依赖和一致性问题。

为了解决这些问题，现代 C++ 提供了模块（C++20 引入），旨在替代传统的头文件和 `#include` 指令，提供更高效的编译方式和更好的封装。模块只需要被编译一次，之后直接使用编译后的二进制结果，这样可以显著减少重复编译和提高编译效率。

>[!success] 什么是防御式头文件
> 防御式头文件主要是解决**单个编译单元**内部避免多次包含同一头文件导致的重复定义问题。它确保头文件的内容在每个编译单元（即每个 `.c` 或 `.cpp` 文件）中只被包括一次。然而，这种机制**不会**影响到不同编译单元之间的行为。每个编译单元是独立处理的，所以即使使用了防御式头文件，每个包含该头文件的源文件在编译时仍然会各自处理一遍头文件内容。这意味着如果你的项目中有多个不同的 `.c` 文件都包含同一个头文件，那么在编译每个 `.c` 文件时，该头文件都会被读取和处理一次。