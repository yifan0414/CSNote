### 运行时环境

你已经成功在 TRM 上运行 `dummy` 程序了, 然而这个程序什么都没做就结束了, 一点也不过瘾啊. 为了让 NEMU 支持大部分程序的运行, 你还需要实现更多的指令. 但并不是有了足够的指令就能运行更多的程序. 我们之前提到"**并不是每一个程序都可以在 NEMU 中运行**", 现在我们来解释一下背后的缘由.

从直觉上来看, 让仅仅只会"计算"的 TRM 来支撑一个功能齐全的操作系统的运行还是不太现实的. 这给我们的感觉就是, 计算机也有一定的"功能强弱"之分, 计算机越"强大", 就能跑越复杂的程序. 换句话说, 程序的运行其实是对计算机的功能有需求的. 在你运行 Hello World 程序时, 你敲入一条命令 (或者点击一下鼠标), 程序就成功运行了, 但这背后其实隐藏着*操作系统开发者*和*库函数开发者*的无数汗水. 一个事实是, 应用程序的运行都需要[运行时环境](http://en.wikipedia.org/wiki/Runtime_system)的支持, 包括加载, 销毁程序, 以及提供程序运行时的各种动态链接库 (你经常使用的库函数就是运行时环境提供的)等. 为了让客户程序在 NEMU 中运行, 现在轮到你来提供相应的运行时环境的支持了.

根据 KISS 法则, 我们先来考虑最简单的运行时环境是什么样的. 换句话说, 为了运行最简单的程序, 我们需要提供什么呢? 其实答案已经在 PA1中了: 只要把程序放在正确的内存位置, 然后让 PC 指向第一条指令, 计算机就会自动执行这个程序, 永不停止.

不过, 虽然计算机可以永不停止地执行指令, 但一般的程序都是会结束的, 所以运行时环境需要向程序提供一种结束运行的方法. 聪明的你已经能想到, 我们在 PA1中提到的那条人工添加的 `nemu_trap` 指令, 就是让程序来结束运行的.

所以, 只要有内存, 有结束运行的方式, 加上实现正确的指令, 就可以支撑最简单程序的运行了. 而这, 也可以算是最简单的运行时环境了.

### 将运行时环境封装成库函数

我们刚才讨论的运行时环境是直接位于计算机硬件之上的, 因此运行时环境的具体实现, 也是和架构相关的. 我们以"ISA-平台"的二元组来表示一个架构, 例如 `mips32-nemu`. 以程序结束为例, NEMU 中是使用人为添加的 `nemu_trap` 指令, 而不同 ISA 的 `nemu_trap` 指令的格式肯定不同; 但如果我们自己用 verilog 设计了一个 riscv32 CPU, 这个 `riscv32-mycpu` 的架构, 有可能是通过一条 `mycpu_trap` 指令来结束程序, 它和 `nemu_trap` 指令有很大概率是不一样的. 而结束运行是程序共有的需求, 为了让 `n` 个程序运行在 `m` 个架构上, 难道我们要维护 `n*m` 份代码? 有没有更好的方法呢?

对于同一个程序, 如果能把 `m` 个版本不同的部分都转换成相同的代码, 我们就只需要维护一个版本就可以了. 而实现这个目标的杀手锏, 就是你在程序设计课上学过的抽象! 我们只需要定义一个结束程序的 API, 比如 `void halt()`, 它对不同架构上程序的不同结束方式进行了抽象: 程序只要调用 `halt()` 就可以结束运行, 而不需要关心自己运行在哪一个架构上. 经过抽象之后, 之前 `m` 个版本的程序, 现在都统一通过 `halt()` 来结束运行, 我们就只需要维护这一个通过 `halt()` 来结束运行的版本就可以了. 然后, 不同的架构分别实现自己的 `halt()`, 就可以支撑 `n` 个程序的运行! 这样以后, 我们就可以把程序和架构解耦了: 我们只需要维护 `n+m` 份代码 (`n` 个程序和 `m` 个架构相关的 `halt()`), 而不是之前的 `n*m`.

这个例子也展示了运行时环境的一种普遍的存在方式: **库**. 通过库, 运行程序所需要的公共要素被抽象成 API, 不同的架构只需要实现这些 API, 也就相当于实现了支撑程序运行的运行时环境, 这提升了程序开发的效率: 需要的时候只要调用这些 API, 就能使用运行时环境提供的相应功能.

```ad-sq
title: 这又能怎么样呢

思考一下, 这样的抽象还会带来哪些好处呢? 你很快就会体会到这些好处了.
```

### AM - 裸机 (bare-metal)运行时环境

一方面, 正如上文提到, 应用程序的运行都需要运行时环境的支持; 另一方面, 只进行纯粹计算任务的程序在 TRM 上就可以运行, 更复杂的应用程序对运行时环境必定还有其它的需求: 例如你之前玩的超级玛丽需要和用户进行交互, 至少需要运行时环境提供输入输出的支持. 要运行一个现代操作系统, 还要在此基础上加入更高级的功能.

如果我们把这些需求都收集起来, 将它们抽象成统一的 API 提供给程序, 这样我们就得到了一个可以支撑各种程序运行在各种架构上的库了! 具体地, 每个架构都按照它们的特性实现这组 API; 应用程序只需要直接调用这组 API 即可, 无需关心自己将来运行在哪个架构上. 由于这组统一抽象的 API 代表了程序运行对计算机的需求, 所以我们把这组 API 称为抽象计算机.

AM (Abstract machine) 项目就是这样诞生的. 作为一个向程序提供运行时环境的库, AM 根据程序的需求把库划分成以下模块

```
AM = TRM + IOE + CTE + VME + MPE
```

- TRM(Turing Machine) - 图灵机, 最简单的运行时环境, 为程序提供基本的计算能力
- IOE(I/O Extension) - 输入输出扩展, 为程序提供输出输入的能力
- CTE(Context Extension) - 上下文扩展, 为程序提供上下文管理的能力
- VME(Virtual Memory Extension) - 虚存扩展, 为程序提供虚存管理的能力
- MPE(Multi-Processor Extension) - 多处理器扩展, 为程序提供多处理器通信的能力 (MPE超出了ICS课程的范围, 在PA中不会涉及)

AM 给我们展示了程序与计算机的关系: 利用计算机硬件的功能实现 AM, 为程序的运行提供它们所需要的运行时环境. 感谢 AM 项目的诞生, 让 NEMU 和程序的界线更加泾渭分明, 同时使得 PA 的流程更加明确:

```
(在NEMU中)实现硬件功能 -> (在AM中)提供运行时环境 -> (在APP层)运行程序
(在NEMU中)实现更强大的硬件功能 -> (在AM中)提供更丰富的运行时环境 -> (在APP层)运行更复杂的程序
```

这个流程其实与 PA1中开天辟地的故事遥相呼应: 先驱希望创造一个计算机的世界, 并赋予它执行程序的使命. 亲自搭建 NEMU (硬件)和 AM (软件)之间的桥梁来支撑程序的运行, 是"理解程序如何在计算机上运行"这一终极目标的不二选择.

```ad-notice
title:AM 的诞生和 Project-N 的故事

在 AM 诞生之前, Project-N 的各个主要部件就已经存在了:

- NEMU - NJU EMUlator (系统基础实验)
- Nanos - Nanjing U OS (操作系统实验)
- NOOP - NJU Out-of-Order Processor (组成原理实验)
- NCC - NJU C Compiler (编译原理实验)

但我们一直没想好, 如何把这些部件集成到一个完整的教学生态系统中.

在2017年春季的计算机系统综合实验课程中, [jyy](http://moon.nju.edu.cn/~jyy/) 首先提出 AM 的思想, 把程序和架构解耦. 解耦之后, AM 就成了 Project-N 的一把关键的钥匙: 只要实现了 AM, 我们就可以在 NEMU 和 NOOP 上运行各种 AM 程序; 只要在 AM 上实现 Nanos, 我们就可以把 Nanos 运行在 NEMU 和 NOOP 上; 只要 NCC 把程序编译到 AM 上, 我们就可以在 NOOP 上运行 NCC 编译的程序.

经过几个月的尝试, 我们很快就相信, 这条路是对的. 于是临时决定将 2017 年秋季的 PA 进行大改版, 借鉴 AM 的思想来设计开发 NEMU, 期望大家能更好地理解"程序如何在计算机上运行". 因此2017年秋季版本的 NEMU, 也算是第一次正式作为一个子项目收录到 Project-N 教学生态系统中.

我们已经连续两年组队参加计算机系统设计大赛"龙芯杯", 在大赛上展示我们独有的Project-N生态系统, 均获得第二名的好成绩. 我们在大赛中探索出来的好方法, 也会反馈到PA中. 这些离你其实并不遥远, 我们在PA中传递出来的做事方法和原则, 都是大赛得奖的黄金经验.

如果你对 AM 和 Project-N 感兴趣, 欢迎联系 jyy 或 yzh.
```

```ad-idea
title:穿越时空的羁绊

有了 AM, 我们就可以把课程之间的实验打通, 做一些以前做不到的有趣的事情了. 比如今年春季的操作系统课上, 你的学长学姐在 AM 上编写了他们自己的小游戏. 在今年 PA 的后期, 你将有机会把学长学姐们编写的游戏无缝地移植到 NEMU 上, 作为最终系统展示的一部分, 想想都是一件激动人心的事情.
```

```ad-sq
title: 为什么要有AM? (建议二周目思考)

操作系统也有自己的运行时环境. AM和操作系统提供的运行时环境有什么不同呢? 为什么会有这些不同?
```

### RTFSC (3)

你已经在 PA0的最后获得了 AM 的子项目 `abstract-machine`, 下面我们来简单介绍一下 AM 项目的代码. 代码中 `abstract-machine/` 目录下的源文件组织如下 (部分目录下的文件并未列出):

```
abstract-machine
├── am                                  # AM相关
│   ├── include
│   │   ├── amdev.h
│   │   ├── am.h
│   │   └── arch                        # 架构相关的头文件定义
│   ├── Makefile
│   └── src
│       ├── native
│       ├── nemu                        # 以NEMU为平台的AM实现
│       │   ├── include
│       │   │   └── nemu.h
│       │   ├── ioe                     # IOE
│       │   │   ├── audio.c
│       │   │   ├── gpu.c
│       │   │   ├── input.c
│       │   │   ├── ioe.c
│       │   │   └── timer.c
│       │   ├── isa
│       │   │   ├── mips32              # mips32相关的实现
│       │   │   │   ├── boot
│       │   │   │   │   ├── loader.ld   # 链接脚本
│       │   │   │   │   └── start.S     # 程序入口
│       │   │   │   ├── cte.c           # CTE
│       │   │   │   ├── trap.S
│       │   │   │   └── vme.c           # VME
│       │   │   ├── riscv32             # riscv32相关的实现
│       │   │   ├── riscv64             # riscv64相关的实现
│       │   │   └── x86                 # x86相关的实现
│       │   ├── mpe.c                   # MPE, 当前为空
│       │   ├── scripts
│       │   │   └── section.ld          # 链接脚本
│       │   └── trm.c                   # TRM
│       ├── riscv32.h
│       ├── riscv64.h
│       └── x86.h
├── klib                                # 常用函数库
├── Makefile                            # 公用的Makefile规则
└── scripts                             # 构建/运行二进制文件/镜像的Makefile
    ├── isa
    │   ├── mips32.mk
    │   ├── riscv32.mk
    │   ├── riscv64.mk
    │   └── x86.mk
    ├── mips32-nemu.mk
    ├── native.mk
    ├── platform
    │   └── nemu.mk
    ├── riscv32-nemu.mk
    ├── riscv64-nemu.mk
    └── x86-nemu.mk
```

整个 AM 项目分为两大部分:

- `abstract-machine/am/` - 不同架构的 AM API 实现, 目前我们只需要关注 NEMU 相关的内容即可. 此外, `abstract-machine/am/include/am.h` 列出了 AM 中的所有 API, 我们会在后续逐一介绍它们.
- `abstract-machine/klib/` - 一些架构无关的库函数, 方便应用程序的开发

阅读 `abstract-machine/am/src/nemu/trm.c` 中的代码, 你会发现只需要实现很少的 API 就可以支撑起程序在 TRM 上运行了:

- `Area heap` 结构用于指示堆区的起始和末尾
- `void putch(char ch)` 用于输出一个字符
- `void halt(int code)` 用于结束程序的运行
- `void _trm_init()` 用于进行 TRM 相关的初始化工作

堆区是给程序自由使用的一段内存区间, 为程序提供动态分配内存的功能. TRM 的 API 只提供堆区的起始和末尾, 而堆区的分配和管理需要程序自行维护. 当然, 程序也可以不使用堆区, 例如 `dummy`. 把 `putch()` 作为 TRM 的 API 是一个很有趣的考虑, 我们在不久的将来再讨论它, 目前我们暂不打算运行需要调用 `putch()` 的程序.

最后来看看 `halt()`. `halt()` 里面调用了 `nemu_trap()` 宏 (在 `abstract-machine/am/src/nemu/include/nemu.h` 中定义), 这个宏展开之后是一条[内联汇编](http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html)语句, 内联汇编语句允许我们在 C 代码中嵌入汇编语句, 显然, 这个宏的定义是和 ISA 相关的. 同时, 这条指令和我们常见的汇编指令不一样 (例如 `movl $1, %eax`), 它是直接通过指令的二进制编码给出的. 如果你查看 `nemu/src/isa/$ISA/exec/exec.c`, 你会发现, 这条指令正是那条特殊的 `nemu_trap`! 这其实也说明了为什么要通过编码来给出这条指令, 以 x86为例, 如果你使用以下方式来给出指令, 汇编器将会报错:

```c
asm volatile("nemu_trap" : : "a" (0))
```

因为这条特殊的指令是我们人为添加的, 标准的汇编器并不能识别它. 如果你查看 objdump 的反汇编结果, 你会看到 `nemu_trap` 指令被标识为 `(bad)`, 原因是类似的: objdump 并不能识别我们人为添加的 `nemu_trap` 指令. `"a"(0)` 是 x86的专用记号, 表示在执行内联汇编语句给出的汇编代码之前, 先将 `0` 读入 `%eax` 寄存器. 这样, 这段汇编代码的功能就和 `nemu/src/isa/x86/exec/special.c` 中的执行辅助函数 `exec_nemu_trap()` 对应起来了: `cpu.eax` 中的值将会作为程序结束的返回值传给 NEMU 的 monitor, monitor 将会根据这个返回值来报告程序结束的原因. 此外, `volatile` 是 C 语言的一个关键字, 如果你想了解关于 `volatile` 的更多信息, 请查阅相关资料.

`am-kernels` 子项目用于收录一些可以在 AM 上运行的测试集和简单程序:

```
am-kernels
├── benchmarks                  # 可用于衡量性能的基准测试程序
│   ├── coremark
│   ├── dhrystone
│   └── microbench
├── kernels                     # 可展示的应用程序
│   ├── hello
│   ├── litenes                 # 简单的NES模拟器
│   ├── slider                  # 简易图片浏览器
│   ├── thread-os               # 内核线程操作系统
│   └── typing-game             # 打字小游戏
└── tests                       # 一些具有针对性的测试集
    ├── am-tests                # 针对AM API实现的测试集
    └── cpu-tests               # 针对CPU指令实现的测试集
```

在让 NEMU 运行客户程序之前, **我们需要将客户程序的代码编译成可执行文件**. 需要说明的是, 我们不能使用 gcc 的默认选项直接编译, 因为默认选项会根据 GNU/Linux 的运行时环境将代码编译成运行在 GNU/Linux 下的可执行文件. 但此时的 NEMU 并不能为客户程序提供 GNU/Linux 的运行时环境, 在 NEMU 中无法正确运行上述可执行文件, 因此我们不能使用 gcc 的默认选项来编译用户程序.

解决这个问题的方法是[交叉编译](http://en.wikipedia.org/wiki/Cross_compiler). 我们需要在 GNU/Linux 下根据 AM 的运行时环境编译出能够在 `$ISA-nemu` 这个新环境中运行的可执行文件. 为了不让链接器 ld 使用默认的方式链接, 我们还需要提供描述 `$ISA-nemu` 的运行时环境的链接脚本. AM 的框架代码已经把相应的配置准备好了, 上述编译和链接选项主要位于 `abstract-machine/Makefile` 以及 `abstract-machine/scripts/` 目录下的相关 `.mk` 文件中. 编译生成一个可以在 NEMU 的运行时环境上运行的程序的过程大致如下:

- gcc 将 `$ISA-nemu` 的 AM 实现源文件编译成目标文件, 然后通过 ar 将这些目标文件作为一个库, 打包成一个归档文件 `abstract-machine/am/build/am-$ISA-nemu.a`
- gcc 把应用程序源文件 (如 `am-kernels/tests/cpu-tests/tests/dummy.c`)编译成目标文件
- 通过 gcc 和 ar 把程序依赖的运行库 (如 `abstract-machine/klib/`)也编译并打包成归档文件
- 根据 Makefile 文件 `abstract-machine/scripts/$ISA-nemu.mk` 中的指示, 让 ld 根据链接脚本 `abstract-machine/am/src/nemu/isa/$ISA/boot/loader.ld`, 将上述目标文件和归档文件链接成可执行文件

上述链接脚本会包含位于 `abstract-machine/am/src/nemu/scripts/section.ld` 的另一个链接脚本. 根据它的指示, 可执行程序重定位后的节从 `0x100000` 或 `0x80100000` 开始 (取决于 `_pmem_start` 的值), 首先是 `.text` 节, 其中又以 `abstract-machine/am/src/nemu/isa/$ISA/boot/start.S` 中自定义的 `entry` 节开始, 然后接下来是其它目标文件的 `.text` 节. 这样, 可执行程序起始处总是放置 `start.S` 的代码, 而不是其它代码, 保证客户程序总能从 `start.S` 开始正确执行. 链接脚本也定义了其它节 (包括 `.rodata`, `.data`, `.bss`)的链接顺序, 还定义了一些关于位置信息的符号, 包括每个节的末尾, 栈顶位置, 堆区的起始和末尾.

我们对编译得到的可执行文件的行为进行简单的梳理:

1. 第一条指令从 `abstract-machine/am/src/nemu/isa/$ISA/boot/start.S` 开始, 设置好栈顶之后就跳转到 `abstract-machine/am/src/nemu/trm.c` 的 `_trm_init()` 函数处执行.
2. 在 `_trm_init()` 中调用 `main()` 函数执行程序的主体功能, `main()` 函数还带一个参数, 目前我们暂时不会用到, 后面我们再介绍它.
3. 从 `main()` 函数返回后, 调用 `halt()` 结束运行.

有了 TRM 这个简单的运行时环境, 我们就可以很容易地在上面运行各种"简单"的程序了. 当然, 我们也可以运行"不简单"的程序: 我们可以实现任意复杂的算法, 甚至是各种理论上可计算的问题, 都可以在 TRM 上解决.

```ad-edit
title:阅读 Makefile

`abstract-machine` 项目的 Makefile 设计得非常巧妙, 你需要把它们看成一种代码来 RTFSC, 从而理解它们是如何工作的. 这样一来, 你就知道怎么编写有一定质量的 Makefile 了; 同时, 如果哪天 Makefile 出现了非预期的行为, 你就可以尝试对 Makefile 进行调试了. 当然, 这少不了 [RTFM](http://www.gnu.org/software/make/manual/make.pdf).
```

### 运行更多的程序

未测试代码永远是错的, 你需要足够多的测试用例来测试你的 NEMU. 我们在 `am-kernels/tests/cpu-tests/` 目录下准备了一些简单的测试用例. 在该目录下执行

```bash
make ARCH=$ISA-nemu ALL=xxx run
```

其中 `xxx` 为测试用例的名称 (不包含 `.c` 后缀).

上述 `make run` 的命令最终会启动 NEMU, 并运行相应的客户程序. 如果你需要使用 GDB 来调试 NEMU 运行客户程序的情况, 可以执行以下命令:

```bash
make ARCH=$ISA-nemu ALL=xxx gdb
```

```ad-edit
title:实现更多的指令

你需要实现更多的指令, 以通过上述测试用例.

你可以自由选择按照什么顺序来实现指令. 经过 PA1的训练之后, 你应该不会实现所有指令之后才进行测试了. 要养成尽早做测试的好习惯, 一般原则都是"实现尽可能少的指令来进行下一次的测试". 你不需要实现所有指令的所有形式, 只需要通过这些测试即可. 如果将来仍然遇到了未实现的指令, 就到时候再实现它们.

框架代码已经实现了部分指令, 但并没有填写相应的 `case` 分支. 此外, 部分函数的功能也并没有完全实现好 (框架代码中已经插入了 `TODO()` 作为提示), 你还需要编写相应的功能.

由于 `string` 和 `hello-str` 还需要实现额外的内容才能运行 (具体在下文介绍), 目前可以先使用其它测试用例进行测试.
```

```ad-notice
title:不要以为只需要在 TODO 处写代码

过去经常有同学认为, "我只需要在出现 `TODO` 的地方写代码就可以了, 如果一个功能在框架代码中没有相应的 `TODO`, 它就是超出必做内容的范围, 我不需要实现."

在 PA 中, 这种想法是错误的. 如果你 RTFSC, 你会发现 `TODO()` 只是个宏, 展开之后会调用 `panic()`. 因此框架代码中的 `TODO` 更多地是在 NEMU 运行的时候给出可读性更好的结果 (如 xxx 未实现), 而不是让 NEMU 触发让你畏惧的段错误.

你毕业后进入公司/课题组, 不会再有讲义具体地告诉你应该做什么, 总有一天你需要在脱离讲义的情况下完成任务. 我们希望你现在就放弃"讲义和框架代码会把我应该做的一切细节清楚地告诉我"的幻想, 为自己承担起"理解整个系统工作原理"的责任, 而不是成为框架代码的奴仆. 因此, 当你疑惑一个功能是否需要实现时, 你不应该通过框架代码中是否有 `TODO` 来进行判断, 而是应该根据你对代码的理解和当下的需求来做决定.
```

```ad-cloud
title:调试的利器 - 日志

我们已经知道程序是个状态机, 如果程序变得复杂, 这个状态机的转移情况也会变得复杂. 先不说状态机中每个状态的细节, 就连状态机进行了怎么样的转移, 我们也很难完全搞清楚.

如果通过GDB来了解这一过程, 效率就会显得有点低了. 为了提高效率, 我们可以通过`printf()`来输出我们关心的某些信息, 这些信息可以作为日志告诉我们程序是如何运行的.

NEMU已经实现了一个简单的指令日志子系统, 它可以记录客户程序执行的每一条指令. 在打开`nemu/include/common.h`中的`DEBUG`宏的情况下运行NEMU, 客户程序执行的指令都会被记录到`build/nemu-log.txt`中. 查看这个文件, 你就可以知道客户程序是如何运行的了.

一般来说, 我们只会关心出错现场前的日志, 在运行一些大程序的时候, 运行前期的日志大多时候没有查看甚至输出的必要. NEMU可以限制指令日志输出的时机, 你可以手动指定什么时候才输出它们, 具体如何指定, RTFSC. 由于目前程序的行为都是确定的, 多次运行会得到相同的结果, 这对我们了解程序什么时候出错是很有帮助的.

对于一些输出规整的日志, 我们还可以通过`grep`, `awk`, `sed` 等文本处理工具来对日志的内容进行筛选和处理. 因此如果你掌握一些用于文本处理的shell命令, 你就可以进一步提高调试的效率了.
```

```ad-must
title: x86指令相关的注意事项

- `push imm8` 指令行为补充. `push imm8` 指令需要对立即数进行符号扩展, 这一点在 i386手册中并没有明确说明. 在 [IA-32手册](http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf)中关于 `push` 指令有如下说明:
    
    > If the source operand is an immediate and its size is less than the operand size, a sign-extended value is pushed on the stack.
    
- 字符串操作指令. 如 `movsb` 等, 这些指令需要用到段寄存器 `DS`, `ES` 以及 EFLAGS 寄存器中的 `DF` 标志. 在 PA 中无需实现这些寄存器, RTFM 时认为这些寄存器的值恒为 `0` 来理解指令的语义即可.
- `endbr32`指令. 具体见[这里](https://nju-projectn.github.io/ics-pa-gitbook/ics2020/2.2.html#%E5%8E%BB%E9%99%A4endbr32%E6%8C%87%E4%BB%A4)
```

```ad-sq
title: mips32的分支延迟槽

为了提升处理器的性能, mips使用了一种叫[分支延迟槽](https://en.wikipedia.org/wiki/Delay_slot)的技术. 采用这种技术之后, 程序的执行顺序会发生一些改变: 我们把紧跟在跳转指令(包括有条件和无条件)之后的静态指令称为延迟槽, 那么程序在执行完跳转指令后, 会先执行延迟槽中的指令, 再执行位于跳转目标的指令. 例如

~~~
100: beq 200
101: add
102: xor
...
200: sub
201: j   102
202: slt
~~~

若 `beq` 指令的执行结果为跳转, 则相应的动态指令流为 `100 -> 101 -> 200`; 若 `beq` 指令的执行结果为不跳转, 则相应的动态指令流为 `100 -> 101 -> 102`; 而对于 `j` 指令, 相应的动态指令流为 `201 -> 202 -> 102`.

你一定会对这种反直觉的技术如何提升处理器性能而感到疑惑. 不过这需要你先了解一些微结构的知识, 例如[处理器流水线](http://en.wikipedia.org/wiki/Classic_RISC_pipeline), 但这已经超出了 ICS 的课程范围了, 所以我们也不详细解释了, 感兴趣的话可以 STFW.

但我们可以知道, 延迟槽技术需要软硬件协同才能正确工作: mips 手册中描述了这一约定, 处理器设计者按照这一约定设计处理器, 而编译器开发者则会让编译器负责在延迟槽中放置一条有意义的指令, 使得无论是否跳转, 按照这一约定的执行顺序都能得到正确的执行结果.

如果你是编译器开发者, 你将会如何寻找合适的指令放到延迟槽中呢?
```

```ad-cloud
title:mips32-NEMU 的分支延迟槽

既然 mips 有这样的约定, 而编译器也已经遵循这一约定, 那么对于 mips32编译器生成的程序, 我们也应该遵循这一约定来解释其语义. 这意味着, mips32-NEMU 作为一个模拟的 mips32 CPU, 也需要实现分支延迟槽技术, 才能正确地支撑 mips32程序的运行.

事实上, gcc 为 mips32程序的生成提供了一个 `-fno-delayed-branch` 的编译选项, 让 mips32程序中的延迟槽中都放置 `nop` 指令. 这样以后, 执行跳转指令之后, 接下来就可以直接执行跳转目标的指令了, 因为延迟槽中都是 `nop` 指令, 就算不执行它, 也不会影响程序的正确性.

在 AM 中, Makefile 已经添加了这一编译选项, 于是我们在实现 mips32-NEMU 的时候就可以进行简化, 无需实现分支延迟槽了.

对 PA 来说, 去掉延迟槽还有其它的好处, 我们会在后续内容中进行讨论.
```

```ad-sq
title:指令名对照

AT&T 格式反汇编结果中的少量指令, 与手册中列出的指令名称不符, 如 x86的 `cltd`, mips32和 riscv32则有不少伪指令 (pseudo instruction). 除了 STFW 之外, 你有办法在手册中找到对应的指令吗? 如果有的话, 为什么这个办法是有效的呢?
```

### 实现常用的库函数

我们已经在 TRM 上运行了不少简单的程序了, 但如果想在 TRM 上编写一些稍微复杂的程序, 我们就会发现有点不方便. 目前 TRM 这个最简单的运行时环境只提供了堆区和 `halt()`, 但我们平时经常使用的像 `memcpy()` 这样的库函数却没有提供. 既然没有提供, 那就让我们来实现一下吧.

既然叫得起库函数, 那说明很多程序都可以用到它们, 所以我们可以像 AM 那样, 把它们组织成一个库. 然而和 AM 不同的是, 这些库函数的具体实现可以是和架构无关的: 与 `halt()` 不同, 在 NEMU 上, 或者在你将来用 verilog 实现的 CPU 上, 甚至是其它的架构, `memcpy()` 都可以通过相同的方式来实现. 所以, 如果在 AM 中来实现这些常用的库函数, 就会引入不必要的重复代码.

一种好的做法是把运行时环境分成两部分: 一部分是**架构相关的运行时环境**, 也就是我们之前介绍的 AM; 另一部分是**架构无关的运行时环境**, 类似 `memcpy()` 这种常用的函数应该归入这部分, `abstract-machine/klib/` 用于收录这些架构无关的库函数. `klib` 是 `kernel library` 的意思, 用于提供一些兼容 libc 的基础功能. 框架代码在 `abstract-machine/klib/src/string.c` 和 `abstract-machine/klib/src/stdio.c` 中列出了将来可能会用到的库函数, 但并没有提供相应的实现.

```ad-edit
title: 实现字符串处理函数

根据需要实现 `abstract-machine/klib/src/string.c` 中列出的字符串处理函数, 让 `cpu-tests` 中的测试用例 `string` 可以成功运行. 关于这些库函数的具体行为, 请务必 RTFM.
```

```ad-notice
title: 免责声明

有一些库函数可能在将来才会使用, 目前你可以选择暂时不实现它们. 但如果将来你因为忘记实现它们而导致程序出错时, 请不要抱怨讲义没有提醒你什么时候应该去实现哪个库函数.

这其实是一个代码管理的问题, 在项目中, 这种情况还是比较常见的. 比如你一下子定义了一堆 API, 但不一定来得及马上把它们全部实现. 反过来, 你应该思考, 有没有更好的方法可以在你用到某个没有实现的函数的时候提醒你, 而不是让你经历一段没有必要的调试过程才发现竟然是个让你哭笑不得的原因呢? #pa
```

为了运行测试用例 `hello-str`, 你还需要实现库函数 `sprintf()`. 和其它库函数相比, `sprintf()` 比较特殊, 因为它的参数数目是可变的. 为了获得数目可变的参数, 你可以使用 C 库 `stdarg.h` 中提供的宏, 具体用法请查阅 `man stdarg`.

```ad-edit
title: 实现 sprintf

实现`abstract-machine/klib/src/stdio.c`中的`sprintf()`, 具体行为可以参考`man 3 printf`. 目前你只需要实现`%s`和`%d`就能通过`hello-str`的测试了, 其它功能(包括位宽, 精度等)可以在将来需要的时候再自行实现.
```

```ad-sq
title: stdarg 是如何实现的?

`stdarg.h` 中包含一些获取函数调用参数的宏, 它们可以看做是调用约定中关于参数传递方式的抽象. 不同 ISA 的 ABI 规范会定义不同的函数参数传递方式, 如果让你来实现这些宏, 你会如何实现?
```

### 重新认识计算机: 计算机是个抽象层

我们在PA1中介绍了"程序在计算机上运行"的微观视角: 程序是个状态机. 状态机视角可以从指令层次精确地描述程序运行的每一处细节, 但这丢失了程序的语义. 对于一些简单的程序, 你还可以把状态机画出来, 但面对一些复杂的程序, 状态机视角就不能帮助我们了. 为了更好地理解复杂程序, 我们需要从一个新的视角来切入.

我们先来讨论在TRM上运行的程序, 我们对这些程序的需求进行分类, 来看看我们的计算机系统是如何支撑这些需求的.

|TRM|计算|内存申请|结束运行|打印信息|
|---|---|---|---|---|
|运行环境|-|malloc()/free()|-|printf()|
|AM API|-|heap|halt()|putch()|
|ISA接口|指令|物理内存地址空间|nemu_trap指令|I/O方式|
|硬件模块|处理器|物理内存|Monitor|串口|
|电路实现|fetch_decode_exec ()|pmem[]|nemu_state|serial_io_handler ()|

- 计算. 这是程序最基本的需求, 以至于它甚至不属于运行时环境和 AM 的范畴. 所有计算相关的代码 (顺序语句, 分支, 循环, 函数调用等), 都会被编译器编译成功能等价的指令序列, 最终在 CPU 上执行. 在 NEMU 中, 我们通过 `fetch_decode_exec()` 这个函数以及相应的辅助函数来实现"CPU 执行指令"的功能.
- 内存申请. 有的程序需要在运行时刻动态地申请内存来使用. 和 libc 类似, klib 提供了 `malloc()` 和 `free()` 来实现内存的动态管理 (你将来会实现它们), 它们又会使用 TRM 中提供的 API `heap` 来获得堆区的起始和末尾. 而 `heap` 的区间又是由 ISA-平台这个二元组对应的物理内存地址空间来决定的. 这一地址空间对应着物理内存的大小, 在 NEMU 中, 它就是大数组 `pmem[]` 的大小.
- 结束运行. 一般程序都会有结束运行的时候, TRM 提供了一个 `halt()` 的 API 来实现这一功能. 由于这个需求过于简单, 因此无需运行时环境提供更复杂的接口. `halt()` 的具体实现和 ISA 有关, 我们使用了人为添加的 `nemu_trap` 指令来实现这一点. 执行 `nemu_trap` 指令会让 NEMU 从 CPU 执行指令的循环中跳出, 返回到 Monitor 中, 这是通过设置 Monitor 中的一个状态变量 `nemu_state` 来实现的.
- 打印信息. 输出是程序的另一个基本需求. 程序可以调用 klib 中的 `printf()` 来输出, 它会通过 TRM 的 API `putch()` 来输出字符. 不同的 ISA-平台有不同的字符输出方式, 在$ISA-nemu 中, `putch()` 通过 I/O 相关的指令把字符写入到串口, 最终在 NEMU 中通过 `serial_io_handler()` 将字符打印到终端. 关于输入输出的更多细节会在 PA2的最后部分进行介绍.

```ad-notice
title: "程序在计算机上运行"的宏观视角: 计算机是个抽象层

在之前的PA中, 我们一直都在强调"程序是个状态机"这个微观视角, 让大家站在底层来理解这个状态机是如何工作的. 现在我们终于有机会向高层远眺, 来理解计算机是如何把底层的功能经过层层抽象, 最终支撑程序的运行.

每一层抽象都有它存在的理由:

- 概念相同的一个硬件模块有着不同的实现方式, 比如处理器既可以通过 NEMU 中简单的解释方式来实现, 也可以通过类似 QEMU 中高性能的二进制翻译方式来实现, 甚至可以通过 verilog 等硬件描述语言来实现一个真实的处理器.
- ISA是硬件向软件提供的可以操作硬件的接口
- AM 的 API 对不同 ISA (如 x86/mips32/riscv32) 的接口进行了抽象, 为上层的程序屏蔽 ISA 相关的细节
- 运行时环境可以通过对AM的API进行进一步的封装, 向程序提供更方便的功能

这些抽象都是为了方便我们在各种各样的计算机系统中编写运行五花八门的程序, 你将要在 PA3中运行的仙剑奇侠传, 也都是通过层层抽象分解成最基本的硬件操作, 最后以状态机的方式来运行.
```


>[!abstract]
>PA 究竟在做什么?
>
>到此为止, 我们已经将 PA 中最重要的两个关于"程序在计算机上运行"的视角介绍完了:
>
>- 微观视角: 程序是个状态机
>- 宏观视角: 计算机是个抽象层
>
>PA 剩下的内容就是借鉴 AM 的启发, 按照计算机发展史的顺序给计算机硬件添加各种新特性, 并强化运行时环境的功能, 最后运行各种更复杂的程序. PA 会把添加新特性的过程作为案例, 让大家不断地从这两个视角来理解"程序如何在计算机上运行". 具体地, 在 PA2 的最后, 我们会添加 IOE 来实现一个冯诺依曼计算机系统; 在 PA3 中, 我们会添加 CTE, 来支持批处理系统的运行; 在最后的 PA4 中, 我们会添加 VME, 来运行一个简单又酷炫的分时多任务系统.
>
>我们在这里给出 PA 的一个全局概念图 (图中的"运行时环境"包含了 AM, klib, 甚至是 OS 和 libc), 这个图的三维坐标轴总结了 PA 中 3 个最重要的结论, 也向大家展示了 PA 构建计算机系统的全过程. 大家在做实验的时候也可以多多思考: 我现在写的代码究竟位于哪一个抽象层? 代码的具体行为究竟是什么? ![pa-concept](https://nju-projectn.github.io/ics-pa-gitbook/ics2020/images/pa-concept.png)