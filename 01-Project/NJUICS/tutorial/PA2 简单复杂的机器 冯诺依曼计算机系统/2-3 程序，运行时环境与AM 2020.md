### 运行时环境

你已经成功在 TRM 上运行 `dummy` 程序了, 然而这个程序什么都没做就结束了, 一点也不过瘾啊. 为了让 NEMU 支持大部分程序的运行, 你还需要实现更多的指令. 但并不是有了足够的指令就能运行更多的程序. 我们之前提到"**并不是每一个程序都可以在 NEMU 中运行**", 现在我们来解释一下背后的缘由.

从直觉上来看, 让仅仅只会"计算"的 TRM 来支撑一个功能齐全的操作系统的运行还是不太现实的. 这给我们的感觉就是, 计算机也有一定的"功能强弱"之分, 计算机越"强大", 就能跑越复杂的程序. 换句话说, 程序的运行其实是对计算机的功能有需求的. 在你运行 Hello World 程序时, 你敲入一条命令 (或者点击一下鼠标), 程序就成功运行了, 但这背后其实隐藏着*操作系统开发者*和*库函数开发者*的无数汗水. 一个事实是, 应用程序的运行都需要[运行时环境](http://en.wikipedia.org/wiki/Runtime_system)的支持, 包括加载, 销毁程序, 以及提供程序运行时的各种动态链接库 (**你经常使用的库函数就是运行时环境提供的**)等. 为了让客户程序在 NEMU 中运行, 现在轮到你来提供相应的运行时环境的支持了.

根据 KISS 法则, 我们先来考虑最简单的运行时环境是什么样的. 换句话说, 为了运行最简单的程序, 我们需要提供什么呢? 其实答案已经在 PA1中了: **只要把程序放在正确的内存位置, 然后让 PC 指向第一条指令, 计算机就会自动执行这个程序, 永不停止**.

不过, 虽然计算机可以永不停止地执行指令, 但一般的程序都是会结束的, 所以运行时环境需要向程序提供一种结束运行的方法. 聪明的你已经能想到, 我们在 PA1中提到的那条人工添加的 `nemu_trap` 指令, 就是让程序来结束运行的.

所以, 只要有内存, 有结束运行的方式, 加上实现正确的指令, 就可以支撑最简单程序的运行了. 而这, 也可以算是最简单的**运行时环境**了.

### 将运行时环境封装成库函数 #star

我们刚才讨论的运行时环境是直接位于计算机硬件之上的, 因此运行时环境的具体实现, 也是和架构相关的. 我们以"ISA-平台"的二元组来表示一个架构, 例如 `mips32-nemu`. 以程序结束为例, NEMU 中是使用人为添加的 `nemu_trap` 指令, 而不同 ISA 的 `nemu_trap` 指令的格式肯定不同; 但如果我们自己用 verilog 设计了一个 riscv32 CPU, 这个 `riscv32-mycpu` 的架构, 有可能是通过一条 `mycpu_trap` 指令来结束程序, 它和 `nemu_trap` 指令有很大概率是不一样的. 而结束运行是程序共有的需求, 为了让 `n` 个程序运行在 `m` 个架构上, 难道我们要维护 `n*m` 份代码? 有没有更好的方法呢?

对于同一个程序, 如果能把 `m` 个版本不同的部分都转换成相同的代码, 我们就只需要维护一个版本就可以了. 而实现这个目标的杀手锏, 就是你在程序设计课上学过的抽象! 我们只需要定义一个结束程序的 API, 比如 `void halt()`, 它对不同架构上程序的不同结束方式进行了抽象: **程序只要调用 `halt()` 就可以结束运行, 而不需要关心自己运行在哪一个架构上**. 经过抽象之后, 之前 `m` 个版本的程序, 现在都统一通过 `halt()` 来结束运行, 我们就只需要维护这一个通过 `halt()` 来结束运行的版本就可以了. 然后, 不同的架构分别实现自己的 `halt()`, 就可以支撑 `n` 个程序的运行! 这样以后, 我们就可以把程序和架构解耦了: 我们只需要维护 `n+m` 份代码 (`n` 个程序和 `m` 个架构相关的 `halt()`), 而不是之前的 `n*m`.

```c
#include ISA_H // "x86.h", "mips32.h", ...

#if defined(__ISA_X86__) // x86架构
# define nemu_trap(code) asm volatile (".byte 0xd6" : :"a"(code))
#elif defined(__ISA_MIPS32__) // mips32架构
# define nemu_trap(code) asm volatile ("move $v0, %0; .word 0xf0000000" : :"r"(code))
#elif defined(__ISA_RISCV32__) || defined(__ISA_RISCV64__) // riscv 架构
# define nemu_trap(code) asm volatile("mv a0, %0; .word 0x0000006b" : :"r"(code))
#elif
# error unsupported ISA __ISA__
#endif

void halt(int code) {
  nemu_trap(code);

  // should not reach here
  while (1);
}
```

这个例子也展示了运行时环境的一种普遍的存在方式: **库**. 通过库, 运行程序所需要的公共要素被抽象成 API, 不同的架构只需要实现这些 API, 也就相当于实现了支撑程序运行的运行时环境, 这提升了程序开发的效率: 需要的时候只要调用这些 API, 就能使用运行时环境提供的相应功能.

> [!idea] 运行时环境是静态链接还是动态链接
> 运行时环境可以涉及到静态链接和动态链接的两种情况。
> 
> 1. **静态链接**：在编译阶段，所有的库函数和程序代码都会被链接到同一个可执行文件中，**构成一个完整的、独立的运行时环境。**这样的运行时环境会在程序启动时一次性加载到内存中。静态链接的优点是可执行文件可以独立运行，不依赖于任何外部的库文件。但是它的缺点是可执行文件的大小通常较大，而且无法利用动态链接库的优点（如共享内存和延迟加载）。
> 
> 2. **动态链接**：在编译阶段，只会将程序代码编译成可执行文件，而库函数则编译成动态链接库（如 .dll 或 .so 文件）。当程序运行时，动态链接库才会被加载到内存中。这种方式可以使得多个程序共享同一个库的一个副本，节省内存，并且可以在不重新编译程序的情况下更新库函数。这样的运行时环境是动态构建的，因为它依赖于运行时的库文件。
> 
> 综上，运行时环境可以是静态链接的，也可以是动态链接的，取决于程序的设计和需求。


> [!idea] 考虑下为什么 JAVA 可以通过 JVM 在任何平台上运行
> ![[JVM|400]]
> JVM 是一个抽象层，也可以说是运行时环境。他为运行其上的程序提供了各种 API（可能是系统调用、内存管理或者线程管理），这些 API 的实现由不同平台的 JVM 实现，根据不同的操作系统作出相应的优化。这也就是大名鼎鼎的 JAVA 设计理念：一次编译，到处运行。（例如在 Windows 平台上编译，在 Linux 平台上执行）
> ```ad-chatgpt
> title: JVM的抽象是对操作系统的抽象还是对CPU指令集的抽象
> Java虚拟机（JVM）的抽象主要是对CPU指令集的抽象，但也在一定程度上对操作系统进行了抽象。
> 
> 首先，JVM定义了自己的指令集（字节码），这可以看作是对CPU指令集的抽象。当你使用Java语言编写程序并编译后，你的Java代码将被转换成这些字节码。这些字节码可以在任何安装了JVM的设备上运行，无论这个设备使用的是什么CPU和操作系统。这**是因为JVM负责将这些字节码翻译成特定平台的机器语言，从而实现了代码的跨平台运行。**
> 
> 其次，JVM也在一定程度上抽象了操作系统。例如，JVM通过Java类库提供了统一的API来进行文件I/O、网络通信、图形用户界面等操作。这些API的实现在不同的操作系统上可能是不同的，但对Java程序员来说，他们无需关心这些差异，因为Java类库为他们提供了统一的接口。这意味着你可以在一种操作系统上编写Java程序，然后在另一种操作系统上运行，而无需修改代码。
> 
> 总的来说，JVM既抽象了CPU指令集，也抽象了操作系统，从而实现了Java语言的"一次编译，到处运行"的特性。
> ```
> 
> ```ad-chatgpt
> title: JVM 和 操作系统的关系
> Java虚拟机（JVM）和操作系统有密切的关系。JVM是Java运行环境的核心部分，负责执行Java字节码，这些字节码通常是Java源代码经过编译器编译得到的。这种设计使得Java程序可以在各种不同的操作系统上运行，只要这些系统上安装了相应版本的JVM。
> 
> JVM与操作系统的关系如下：
> 
> 1. **运行在操作系统之上**：JVM运行在操作系统之上，使用操作系统提供的各种服务，包括内存管理、线程调度、文件I/O、网络通信等。JVM将这些底层服务封装，并提供一套统一的、跨平台的API给Java程序。
> 
> 2. **依赖于操作系统**：虽然JVM的目标是使Java程序可以跨平台运行，但JVM本身是依赖于特定操作系统的。JVM需要针对每种操作系统进行特定的实现，以便利用和控制操作系统提供的底层资源。
> 
> 3. **提供抽象层**：JVM为Java程序提供了一个抽象的运行环境，使得Java程序无需关心底层操作系统的具体细节。这种抽象层包括了一套虚拟的指令集（Java字节码）和一套运行时系统（如内存管理、垃圾回收等）。这样，Java程序只需要面向JVM编程，就可以在任何安装了JVM的系统上运行。
> 
> 总的来说，JVM运行在操作系统之上，依赖于操作系统，但同时也为Java程序提供了一种跨操作系统运行的能力。
> 
> ```
> 
> ```ad-danger
> title: C 语言的跨平台特性呢？
> C 语言的跨平台特性主要是由各个平台上的编译器决定的，不同系统的编译器会将相同的C语言代码编译成相应平台上的二进制文件，然后运行。但不同平台编译的二进制文件不能互相运行。
> ```

> [!sq] 这又能怎么样呢
> 
> 也许上面的文字并不能"忽悠"清醒的你: 现在不就只有NEMU这一个机器吗( `m=1` )? 哪里需要抽象?
> 
> 思考一下, 这样的抽象还会带来哪些好处呢? 你很快就会体会到这些好处了.

### AM - 裸机 (bare-metal)运行时环境

一方面, 正如上文提到, 应用程序的运行都需要运行时环境的支持; 另一方面, 只进行纯粹计算任务的程序在 TRM 上就可以运行, 更复杂的应用程序对运行时环境必定还有其它的需求: 例如你之前玩的超级玛丽需要和用户进行交互, 至少需要运行时环境提供输入输出的支持. 要运行一个现代操作系统, 还要在此基础上加入更高级的功能.

如果我们把这些需求都收集起来, 将它们抽象成统一的 API 提供给程序, 这样我们就得到了一个可以支撑各种程序运行在各种架构上的库了! 具体地, *每个架构都按照它们的特性实现这组 API; 应用程序只需要直接调用这组 API 即可, 无需关心自己将来运行在哪个架构上.* 由于这组统一抽象的 API 代表了程序运行对计算机的需求, 所以我们把这组 API 称为抽象计算机.

AM (Abstract machine) 项目就是这样诞生的. 作为一个向程序提供运行时环境的库, AM 根据程序的需求把库划分成以下模块

```
AM = TRM + IOE + CTE + VME + MPE
```

- TRM(Turing Machine) - 图灵机, 最简单的运行时环境, 为程序提供基本的计算能力
- IOE(I/O Extension) - 输入输出扩展, 为程序提供输出输入的能力
- CTE(Context Extension) - 上下文扩展, 为程序提供上下文管理的能力
- VME(Virtual Memory Extension) - 虚存扩展, 为程序提供虚存管理的能力
- MPE(Multi-Processor Extension) - 多处理器扩展, 为程序提供多处理器通信的能力 (MPE超出了ICS课程的范围, 在PA中不会涉及)

AM 给我们展示了程序与计算机的关系: 利用计算机硬件的功能实现 AM, 为程序的运行提供它们所需要的运行时环境. 感谢 AM 项目的诞生, 让 NEMU 和程序的界线更加泾渭分明, 同时使得 PA 的流程更加明确:

```
(在NEMU中)实现硬件功能 -> (在AM中)提供运行时环境 -> (在APP层)运行程序
(在NEMU中)实现更强大的硬件功能 -> (在AM中)提供更丰富的运行时环境 -> (在APP层)运行更复杂的程序
```

> [!sq] nemu运行在哪里？
> 我的 nemu 不是运行在 Linux 上吗，那么如何使用 AM 提供的运行时环境呢？

这个流程其实与 PA1中开天辟地的故事遥相呼应: 先驱希望创造一个计算机的世界, 并赋予它执行程序的使命. **亲自搭建 NEMU (硬件)和 AM (软件)之间的桥梁来支撑程序的运行**, 是"理解程序如何在计算机上运行"这一终极目标的不二选择。

> [!must] 什么是 AM ？
> 你或许会觉得 NEMU 与 AM 的关系有点模糊不清, 让我们还是来看 ATM 机的例子.
> 
> 说起 ATM 机, 你脑海里一定会想起一个可以存款, 取款, 查询余额, 转账的机器. 我们不妨把你脑海里的这个机器的模型称为抽象 ATM 机. 从用户的角度来说, 用户对 ATM 机的功能是有期望的: 要能存款, 取款, 查询余额, 转账.
> 
> 从银行的角度来说, 不同银行的 ATM 机千差万别: 存款的加密方式, 交易时使用的自定义通信协议, 余额在银行系统里面的表示和组织方式... 不同银行的 ATM 机之间存在这么多细节上的差异, 怎么样才能让用户方便地使用 ATM 机呢? 那就是, 为不同银行的 ATM 机分别实现上文提到的抽象 ATM 机的功能: 只要 ATM 机实现了存款, 取款和查询余额的这组统一的功能, 和用户对抽象 ATM 机的认识匹配上, 用户就可以方便地使用这台 ATM 机, 而不必关心 ATM 机的上述细节.
> 
> 在 NEMU 和 AM 的关系中, 程序就像是用户, AM 就像是抽象 ATM 机, 我们实现 NEMU 这个计算机就像是造一台新的 (虚拟的) ATM 机, 也就像我们在 PA1中提到的, 写一个支付宝 APP. 同样的道理, 程序对计算机的功能是有期望的: 要能计算, 输入输出... 这些功能的期望组成了一台抽象计算机 AM, 它刻画了一台真实计算机应该具备的功能. 但不同计算机的硬件配置各不相同, ISA 也千差万别, 怎么样才能让程序方便地运行呢? 那就是, 为不同的计算机分别实现 AM 的功能: 只要计算机实现了 AM 定义的一组统一的 API, 就能和程序对计算机的功能期望匹配上, 程序就可以方便地在计算机上运行, 而不必关心计算机的底层细节.
> 
> ---
> 
> 有兴趣折腾的同学还可以来理解一下真机, NEMU 和 AM 这三者的关系. 我们会发现, 无论是真实的 ATM 机还是支付宝 APP, 都符合我们对的抽象 ATM 机的认知: 它们都能存款, 取款, 查询余额, 转账. 也正因为如此, 支付宝 APP 刚推出的时候, 我们才能很容易上手: 虽然支付宝 APP 是个虚拟的 ATM 机, 但我们还是可以很容易根据我们对抽象 ATM 机的认知来使用它.
> 
> **回到 NEMU 的例子中来, 我们还是用 ATM 机的例子来比喻: 真机就像是一台真实的 ATM 机, NEMU 这个虚拟机就像是一个支付宝 APP, AM 还是我们概念上的抽象 ATM 机. 只要一台机器实现了 AM 的功能 (能计算, 能输出输入...), 程序都可以在上面运行, 不必关心这台机器是真实的, 还是用程序虚拟出来的.**
> 
> 用一句话来总结这三者的关系: AM 在概念上定义了一台抽象计算机, 它从运行程序的视角刻画了一台计算机应该具备的功能, 而真机和 NEMU 都是这台抽象计算机的具体实现, 只是真机是通过物理上存在的数字电路来实现, NEMU 是通过程序来实现.
> 
> 如果你对面向对象程序设计有一些初步的了解, 解释起来就更简单了:
> 
> > AM 是个抽象类, 真机和虚拟机是由 AM 这个抽象类派生出来的两个子类, 而 x86 真机和 NEMU 则分别是这两个子类的实例化.

> [!notice] AM 的诞生和 Project-N 的故事
> 
> 在 AM 诞生之前, Project-N 的各个主要部件就已经存在了:
> 
> - NEMU - NJU EMUlator (系统基础实验)
> - Nanos - Nanjing U OS (操作系统实验)
> - NOOP - NJU Out-of-Order Processor (组成原理实验)
> - NCC - NJU C Compiler (编译原理实验)
> 
> 但我们一直没想好, 如何把这些部件集成到一个完整的教学生态系统中.
> 
> 在2017年春季的计算机系统综合实验课程中, [jyy](http://moon.nju.edu.cn/~jyy/) 首先提出 AM 的思想, 把程序和架构解耦. 解耦之后, AM 就成了 Project-N 的一把关键的钥匙: 只要实现了 AM, 我们就可以在 NEMU 和 NOOP 上运行各种 AM 程序; 只要在 AM 上实现 Nanos, 我们就可以把 Nanos 运行在 NEMU 和 NOOP 上; 只要 NCC 把程序编译到 AM 上, 我们就可以在 NOOP 上运行 NCC 编译的程序.
> 
> 经过几个月的尝试, 我们很快就相信, 这条路是对的. 于是临时决定将 2017 年秋季的 PA 进行大改版, 借鉴 AM 的思想来设计开发 NEMU, 期望大家能更好地理解"程序如何在计算机上运行". 因此2017年秋季版本的 NEMU, 也算是第一次正式作为一个子项目收录到 Project-N 教学生态系统中.
> 
> 我们已经连续两年组队参加计算机系统设计大赛"龙芯杯", 在大赛上展示我们独有的Project-N生态系统, 均获得第二名的好成绩. 我们在大赛中探索出来的好方法, 也会反馈到PA中. 这些离你其实并不遥远, 我们在PA中传递出来的做事方法和原则, 都是大赛得奖的黄金经验.
> 
> 如果你对 AM 和 Project-N 感兴趣, 欢迎联系 jyy 或 yzh.

> [!idea] 穿越时空的羁绊
> 
> 有了 AM, 我们就可以把课程之间的实验打通, 做一些以前做不到的有趣的事情了. 比如今年春季的操作系统课上, 你的学长学姐在 AM 上编写了他们自己的小游戏. 在今年 PA 的后期, 你将有机会把学长学姐们编写的游戏无缝地移植到 NEMU 上, 作为最终系统展示的一部分, 想想都是一件激动人心的事情.

> [!sq] 为什么要有AM? (建议二周目思考)
> 
> 操作系统也有自己的运行时环境. AM和操作系统提供的运行时环境有什么不同呢? 为什么会有这些不同?
> 
> ~~~ad-chatgpt
> 首先，AM可能是指“应用程序”（Application）。运行时环境（Runtime Environment）是一种为程序运行提供所需服务和资源的环境，既包括操作系统也包括其他一些环境。
> 
> 对于操作系统，它的运行时环境主要包括CPU、内存、硬盘等物理资源，以及由操作系统自身提供的各种服务，如进程调度、内存管理、文件系统、设备驱动等。操作系统是最基本的运行时环境，它是直接运行在硬件上的，为上层的应用程序提供了一种硬件的抽象。
> 
> 对于应用程序，它的运行时环境可能包括操作系统，也可能包括其他一些环境，如Java程序的运行时环境就包括了Java虚拟机（JVM）。这些额外的运行时环境通常为应用程序提供了一些额外的服务，如垃圾回收、异常处理、线程同步等。这些服务在操作系统级别是不存在或者较为原始的，需要通过额外的运行时环境来提供。
> 
> 不同的运行时环境存在的原因主要是因为不同的编程语言和应用需求。例如，C和C++程序可以直接运行在操作系统环境中，它们能够直接访问和管理硬件资源。而Java、Python等语言则提供了一种更高级的抽象，隐藏了许多底层细节，这就需要一个额外的运行时环境（如JVM或Python解释器）来提供这些抽象。
> 
> 总的来说，运行时环境的不同主要反映了不同的抽象层次和服务需求。操作系统提供了对硬件的基本抽象，而其他运行时环境则在此基础上提供了更高级的抽象和服务。
> ~~~
> 

### RTFSC (3)

你已经在 PA0的最后获得了 AM 的子项目 `abstract-machine`, 下面我们来简单介绍一下 AM 项目的代码. 代码中 `abstract-machine/` 目录下的源文件组织如下 (部分目录下的文件并未列出):

```
abstract-machine
├── am                                  # AM相关
│   ├── include
│   │   ├── amdev.h
│   │   ├── am.h
│   │   └── arch                        # 架构相关的头文件定义
│   ├── Makefile
│   └── src
│       ├── native
│       ├── nemu                        # 以NEMU为平台的AM实现
│       │   ├── include
│       │   │   └── nemu.h
│       │   ├── ioe                     # IOE
│       │   │   ├── audio.c
│       │   │   ├── gpu.c
│       │   │   ├── input.c
│       │   │   ├── ioe.c
│       │   │   └── timer.c
│       │   ├── isa
│       │   │   ├── mips32              # mips32相关的实现
│       │   │   │   ├── boot
│       │   │   │   │   ├── loader.ld   # 链接脚本
│       │   │   │   │   └── start.S     # 程序入口
│       │   │   │   ├── cte.c           # CTE
│       │   │   │   ├── trap.S
│       │   │   │   └── vme.c           # VME
│       │   │   ├── riscv32             # riscv32相关的实现
│       │   │   ├── riscv64             # riscv64相关的实现
│       │   │   └── x86                 # x86相关的实现
│       │   ├── mpe.c                   # MPE, 当前为空
│       │   ├── scripts
│       │   │   └── section.ld          # 链接脚本
│       │   └── trm.c                   # TRM
│       ├── riscv32.h
│       ├── riscv64.h
│       └── x86.h
├── klib                                # 常用函数库
├── Makefile                            # 公用的Makefile规则
└── scripts                             # 构建/运行二进制文件/镜像的Makefile
    ├── isa
    │   ├── mips32.mk
    │   ├── riscv32.mk
    │   ├── riscv64.mk
    │   └── x86.mk
    ├── mips32-nemu.mk
    ├── native.mk
    ├── platform
    │   └── nemu.mk
    ├── riscv32-nemu.mk
    ├── riscv64-nemu.mk
    └── x86-nemu.mk
```

整个 AM 项目分为两大部分:

- `abstract-machine/am/` - 不同架构的 AM API 实现, 目前我们只需要关注 NEMU 相关的内容即可. 此外, `abstract-machine/am/include/am.h` 列出了 AM 中的所有 API, 我们会在后续逐一介绍它们.
- `abstract-machine/klib/` - 一些架构无关的库函数, 方便应用程序的开发

阅读 `abstract-machine/am/src/nemu/trm.c` 中的代码, 你会发现只需要实现很少的 API 就可以支撑起程序在 TRM 上运行了:

- `Area heap` 结构用于指示堆区的起始和末尾
- `void putch(char ch)` 用于输出一个字符
- `void halt(int code)` 用于结束程序的运行
- `void _trm_init()` 用于进行 TRM 相关的初始化工作

堆区是给程序自由使用的一段内存区间, 为程序提供动态分配内存的功能. TRM 的 API 只提供堆区的起始和末尾, 而堆区的分配和管理需要程序自行维护. 当然, 程序也可以不使用堆区, 例如 `dummy`. 把 `putch()` 作为 TRM 的 API 是一个很有趣的考虑, 我们在不久的将来再讨论它, 目前我们暂不打算运行需要调用 `putch()` 的程序.

最后来看看 `halt()`. `halt()` 里面调用了 `nemu_trap()` 宏 (在 `abstract-machine/am/src/nemu/include/nemu.h` 中定义), 这个宏展开之后是一条[内联汇编](http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html)语句, 内联汇编语句允许我们在 C 代码中嵌入汇编语句, 显然, 这个宏的定义是和 ISA 相关的. 同时, 这条指令和我们常见的汇编指令不一样 (例如 `movl $1, %eax`), 它是直接通过指令的二进制编码给出的. 如果你查看 `nemu/src/isa/$ISA/exec/exec.c`, 你会发现, 这条指令正是那条特殊的 `nemu_trap`! 这其实也说明了为什么要通过编码来给出这条指令, 以 x86为例, 如果你使用以下方式来给出指令, 汇编器将会报错:

```c
asm volatile("nemu_trap" : : "a" (0))
```

因为这条特殊的指令是我们人为添加的, 标准的汇编器并不能识别它. 如果你查看 objdump 的反汇编结果, 你会看到 `nemu_trap` 指令被标识为 `(bad)`, 原因是类似的: objdump 并不能识别我们人为添加的 `nemu_trap` 指令. `"a"(0)` 是 x86的专用记号, 表示在执行内联汇编语句给出的汇编代码之前, 先将 `0` 读入 `%eax` 寄存器. 这样, 这段汇编代码的功能就和 `nemu/src/isa/x86/exec/special.c` 中的执行辅助函数 `exec_nemu_trap()` 对应起来了: `cpu.eax` 中的值将会作为程序结束的返回值传给 NEMU 的 monitor, monitor 将会根据这个返回值来报告程序结束的原因. 此外, `volatile` 是 C 语言的一个关键字, 如果你想了解关于 `volatile` 的更多信息, 请查阅相关资料.

`am-kernels` 子项目用于收录一些可以在 AM 上运行的测试集和简单程序:

```
am-kernels
├── benchmarks                  # 可用于衡量性能的基准测试程序
│   ├── coremark
│   ├── dhrystone
│   └── microbench
├── kernels                     # 可展示的应用程序
│   ├── hello
│   ├── litenes                 # 简单的NES模拟器
│   ├── slider                  # 简易图片浏览器
│   ├── thread-os               # 内核线程操作系统
│   └── typing-game             # 打字小游戏
└── tests                       # 一些具有针对性的测试集
    ├── am-tests                # 针对AM API实现的测试集
    └── cpu-tests               # 针对CPU指令实现的测试集
```

在让 NEMU 运行客户程序之前, **我们需要将客户程序的代码编译成可执行文件**. 需要说明的是, 我们不能使用 gcc 的默认选项直接编译, 因为默认选项会根据 GNU/Linux 的运行时环境将代码编译成运行在 GNU/Linux 下的可执行文件. 但此时的 NEMU 并不能为客户程序提供 GNU/Linux 的运行时环境, 在 NEMU 中无法正确运行上述可执行文件, 因此我们不能使用 gcc 的默认选项来编译用户程序.

解决这个问题的方法是[交叉编译](http://en.wikipedia.org/wiki/Cross_compiler). 我们需要在 GNU/Linux 下根据 AM 的运行时环境编译出能够在 `$ISA-nemu` 这个新环境中运行的可执行文件. 为了不让链接器 ld 使用默认的方式链接, 我们还需要提供描述 `$ISA-nemu` 的运行时环境的链接脚本. AM 的框架代码已经把相应的配置准备好了, 上述编译和链接选项主要位于 `abstract-machine/Makefile` 以及 `abstract-machine/scripts/` 目录下的相关 `.mk` 文件中. 编译生成一个可以在 NEMU 的运行时环境上运行的程序的过程大致如下:

- gcc 将 `$ISA-nemu` 的 AM 实现源文件编译成目标文件, 然后通过 ar 将这些目标文件作为一个库, 打包成一个归档文件 `abstract-machine/am/build/am-$ISA-nemu.a`
- gcc 把应用程序源文件 (如 `am-kernels/tests/cpu-tests/tests/dummy.c`)编译成目标文件
- 通过 gcc 和 ar 把程序依赖的运行库 (如 `abstract-machine/klib/`)也编译并打包成归档文件
- 根据 Makefile 文件 `abstract-machine/scripts/$ISA-nemu.mk` 中的指示, 让 ld 根据链接脚本 `abstract-machine/am/src/nemu/isa/$ISA/boot/loader.ld`, 将上述目标文件和归档文件链接成可执行文件

上述链接脚本会包含位于 `abstract-machine/am/src/nemu/scripts/section.ld` 的另一个链接脚本. 根据它的指示, 可执行程序重定位后的节从 `0x100000` 或 `0x80100000` 开始 (取决于 `_pmem_start` 的值), 首先是 `.text` 节, 其中又以 `abstract-machine/am/src/nemu/isa/$ISA/boot/start.S` 中自定义的 `entry` 节开始, 然后接下来是其它目标文件的 `.text` 节. 这样, 可执行程序起始处总是放置 `start.S` 的代码, 而不是其它代码, 保证客户程序总能从 `start.S` 开始正确执行. 链接脚本也定义了其它节 (包括 `.rodata`, `.data`, `.bss`)的链接顺序, 还定义了一些关于位置信息的符号, 包括每个节的末尾, 栈顶位置, 堆区的起始和末尾.

我们对编译得到的可执行文件的行为进行简单的梳理:

1. 第一条指令从 `abstract-machine/am/src/nemu/isa/$ISA/boot/start.S` 开始, 设置好栈顶之后就跳转到 `abstract-machine/am/src/nemu/trm.c` 的 `_trm_init()` 函数处执行.
2. 在 `_trm_init()` 中调用 `main()` 函数执行程序的主体功能, `main()` 函数还带一个参数, 目前我们暂时不会用到, 后面我们再介绍它.
3. 从 `main()` 函数返回后, 调用 `halt()` 结束运行.

有了 TRM 这个简单的运行时环境, 我们就可以很容易地在上面运行各种"简单"的程序了. 当然, 我们也可以运行"不简单"的程序: 我们可以实现任意复杂的算法, 甚至是各种理论上可计算的问题, 都可以在 TRM 上解决.

> [!edit] 阅读 Makefile
> 
> `abstract-machine` 项目的 Makefile 设计得非常巧妙, 你需要把它们看成一种代码来 RTFSC, 从而理解它们是如何工作的. 这样一来, 你就知道怎么编写有一定质量的 Makefile 了; 同时, 如果哪天 Makefile 出现了非预期的行为, 你就可以尝试对 Makefile 进行调试了. 当然, 这少不了 [RTFM](http://www.gnu.org/software/make/manual/make.pdf).

### 运行更多的程序

未测试代码永远是错的, 你需要足够多的测试用例来测试你的 NEMU. 我们在 `am-kernels/tests/cpu-tests/` 目录下准备了一些简单的测试用例. 在该目录下执行

```bash
make ARCH=$ISA-nemu ALL=xxx run
```

其中 `xxx` 为测试用例的名称 (不包含 `.c` 后缀).

上述 `make run` 的命令最终会启动 NEMU, 并运行相应的客户程序. 如果你需要使用 GDB 来调试 NEMU 运行客户程序的情况, 可以执行以下命令:

```bash
make ARCH=$ISA-nemu ALL=xxx gdb
```

> [!edit] 实现更多的指令
> 
> 你需要实现更多的指令, 以通过上述测试用例.
> 
> 你可以自由选择按照什么顺序来实现指令. 经过 PA1的训练之后, 你应该不会实现所有指令之后才进行测试了. 要养成尽早做测试的好习惯, 一般原则都是"实现尽可能少的指令来进行下一次的测试". 你不需要实现所有指令的所有形式, 只需要通过这些测试即可. 如果将来仍然遇到了未实现的指令, 就到时候再实现它们.
> 
> 框架代码已经实现了部分指令, 但并没有填写相应的 `case` 分支. 此外, 部分函数的功能也并没有完全实现好 (框架代码中已经插入了 `TODO()` 作为提示), 你还需要编写相应的功能.
> 
> 由于 `string` 和 `hello-str` 还需要实现额外的内容才能运行 (具体在下文介绍), 目前可以先使用其它测试用例进行测试.

> [!notice] 不要以为只需要在 TODO 处写代码
> 
> 过去经常有同学认为, "我只需要在出现 `TODO` 的地方写代码就可以了, 如果一个功能在框架代码中没有相应的 `TODO`, 它就是超出必做内容的范围, 我不需要实现."
> 
> 在 PA 中, 这种想法是错误的. 如果你 RTFSC, 你会发现 `TODO()` 只是个宏, 展开之后会调用 `panic()`. 因此框架代码中的 `TODO` 更多地是在 NEMU 运行的时候给出可读性更好的结果 (如 xxx 未实现), 而不是让 NEMU 触发让你畏惧的段错误.
> 
> 你毕业后进入公司/课题组, 不会再有讲义具体地告诉你应该做什么, 总有一天你需要在脱离讲义的情况下完成任务. 我们希望你现在就放弃"讲义和框架代码会把我应该做的一切细节清楚地告诉我"的幻想, 为自己承担起"理解整个系统工作原理"的责任, 而不是成为框架代码的奴仆. 因此, 当你疑惑一个功能是否需要实现时, 你不应该通过框架代码中是否有 `TODO` 来进行判断, 而是应该根据你对代码的理解和当下的需求来做决定.

> [!cloud] 调试的利器 - 日志
> 
> 我们已经知道程序是个状态机, 如果程序变得复杂, 这个状态机的转移情况也会变得复杂. 先不说状态机中每个状态的细节, 就连状态机进行了怎么样的转移, 我们也很难完全搞清楚.
> 
> 如果通过GDB来了解这一过程, 效率就会显得有点低了. 为了提高效率, 我们可以通过`printf()`来输出我们关心的某些信息, 这些信息可以作为日志告诉我们程序是如何运行的.
> 
> NEMU已经实现了一个简单的指令日志子系统, 它可以记录客户程序执行的每一条指令. 在打开`nemu/include/common.h`中的`DEBUG`宏的情况下运行NEMU, 客户程序执行的指令都会被记录到`build/nemu-log.txt`中. 查看这个文件, 你就可以知道客户程序是如何运行的了.
> 
> 一般来说, 我们只会关心出错现场前的日志, 在运行一些大程序的时候, 运行前期的日志大多时候没有查看甚至输出的必要. NEMU可以限制指令日志输出的时机, 你可以手动指定什么时候才输出它们, 具体如何指定, RTFSC. 由于目前程序的行为都是确定的, 多次运行会得到相同的结果, 这对我们了解程序什么时候出错是很有帮助的.
> 
> 对于一些输出规整的日志, 我们还可以通过`grep`, `awk`, `sed` 等文本处理工具来对日志的内容进行筛选和处理. 因此如果你掌握一些用于文本处理的shell命令, 你就可以进一步提高调试的效率了.

> [!must] x86指令相关的注意事项
> 
> - `push imm8` 指令行为补充. `push imm8` 指令需要对立即数进行符号扩展, 这一点在 i386手册中并没有明确说明. 在 [IA-32手册](http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf)中关于 `push` 指令有如下说明:
>     
>     > If the source operand is an immediate and its size is less than the operand size, a sign-extended value is pushed on the stack.
>     
> - 字符串操作指令. 如 `movsb` 等, 这些指令需要用到段寄存器 `DS`, `ES` 以及 EFLAGS 寄存器中的 `DF` 标志. 在 PA 中无需实现这些寄存器, RTFM 时认为这些寄存器的值恒为 `0` 来理解指令的语义即可.
> - `endbr32`指令. 具体见[这里](https://nju-projectn.github.io/ics-pa-gitbook/ics2020/2.2.html#%E5%8E%BB%E9%99%A4endbr32%E6%8C%87%E4%BB%A4)

> [!sq] mips32的分支延迟槽
> 
> 为了提升处理器的性能, mips使用了一种叫[分支延迟槽](https://en.wikipedia.org/wiki/Delay_slot)的技术. 采用这种技术之后, 程序的执行顺序会发生一些改变: 我们把紧跟在跳转指令(包括有条件和无条件)之后的静态指令称为延迟槽, 那么程序在执行完跳转指令后, 会先执行延迟槽中的指令, 再执行位于跳转目标的指令. 例如
> 
> ~~~
> 100: beq 200
> 101: add
> 102: xor
> ...
> 200: sub
> 201: j   102
> 202: slt
> ~~~
> 
> 若 `beq` 指令的执行结果为跳转, 则相应的动态指令流为 `100 -> 101 -> 200`; 若 `beq` 指令的执行结果为不跳转, 则相应的动态指令流为 `100 -> 101 -> 102`; 而对于 `j` 指令, 相应的动态指令流为 `201 -> 202 -> 102`.
> 
> 你一定会对这种反直觉的技术如何提升处理器性能而感到疑惑. 不过这需要你先了解一些微结构的知识, 例如[处理器流水线](http://en.wikipedia.org/wiki/Classic_RISC_pipeline), 但这已经超出了 ICS 的课程范围了, 所以我们也不详细解释了, 感兴趣的话可以 STFW.
> 
> 但我们可以知道, 延迟槽技术需要软硬件协同才能正确工作: mips 手册中描述了这一约定, 处理器设计者按照这一约定设计处理器, 而编译器开发者则会让编译器负责在延迟槽中放置一条有意义的指令, 使得无论是否跳转, 按照这一约定的执行顺序都能得到正确的执行结果.
> 
> 如果你是编译器开发者, 你将会如何寻找合适的指令放到延迟槽中呢?

> [!cloud] mips32-NEMU 的分支延迟槽
> 
> 既然 mips 有这样的约定, 而编译器也已经遵循这一约定, 那么对于 mips32编译器生成的程序, 我们也应该遵循这一约定来解释其语义. 这意味着, mips32-NEMU 作为一个模拟的 mips32 CPU, 也需要实现分支延迟槽技术, 才能正确地支撑 mips32程序的运行.
> 
> 事实上, gcc 为 mips32程序的生成提供了一个 `-fno-delayed-branch` 的编译选项, 让 mips32程序中的延迟槽中都放置 `nop` 指令. 这样以后, 执行跳转指令之后, 接下来就可以直接执行跳转目标的指令了, 因为延迟槽中都是 `nop` 指令, 就算不执行它, 也不会影响程序的正确性.
> 
> 在 AM 中, Makefile 已经添加了这一编译选项, 于是我们在实现 mips32-NEMU 的时候就可以进行简化, 无需实现分支延迟槽了.
> 
> 对 PA 来说, 去掉延迟槽还有其它的好处, 我们会在后续内容中进行讨论.

> [!sq] 指令名对照
> 
> AT&T 格式反汇编结果中的少量指令, 与手册中列出的指令名称不符, 如 x86的 `cltd`, mips32和 riscv32则有不少伪指令 (pseudo instruction). 除了 STFW 之外, 你有办法在手册中找到对应的指令吗? 如果有的话, 为什么这个办法是有效的呢?

### 实现常用的库函数

我们已经在 TRM 上运行了不少简单的程序了, 但如果想在 TRM 上编写一些稍微复杂的程序, 我们就会发现有点不方便. 目前 TRM 这个最简单的运行时环境只提供了堆区和 `halt()`, 但我们平时经常使用的像 `memcpy()` 这样的库函数却没有提供. 既然没有提供, 那就让我们来实现一下吧.

既然叫得起库函数, 那说明很多程序都可以用到它们, 所以我们可以像 AM 那样, 把它们组织成一个库. 然而和 AM 不同的是, 这些库函数的具体实现可以是和架构无关的: 与 `halt()` 不同, 在 NEMU 上, 或者在你将来用 verilog 实现的 CPU 上, 甚至是其它的架构, `memcpy()` 都可以通过相同的方式来实现. 所以, 如果在 AM 中来实现这些常用的库函数, 就会引入不必要的重复代码.

一种好的做法是把运行时环境分成两部分: 一部分是**架构相关的运行时环境**, 也就是我们之前介绍的 AM; 另一部分是**架构无关的运行时环境**, 类似 `memcpy()` 这种常用的函数应该归入这部分, `abstract-machine/klib/` 用于收录这些架构无关的库函数. `klib` 是 `kernel library` 的意思, 用于提供一些兼容 libc 的基础功能. 框架代码在 `abstract-machine/klib/src/string.c` 和 `abstract-machine/klib/src/stdio.c` 中列出了将来可能会用到的库函数, 但并没有提供相应的实现.

> [!edit] 实现字符串处理函数
> 
> 根据需要实现 `abstract-machine/klib/src/string.c` 中列出的字符串处理函数, 让 `cpu-tests` 中的测试用例 `string` 可以成功运行. 关于这些库函数的具体行为, 请务必 RTFM.

> [!notice] 免责声明
> 
> 有一些库函数可能在将来才会使用, 目前你可以选择暂时不实现它们. 但如果将来你因为忘记实现它们而导致程序出错时, 请不要抱怨讲义没有提醒你什么时候应该去实现哪个库函数.
> 
> 这其实是一个代码管理的问题, 在项目中, 这种情况还是比较常见的. 比如你一下子定义了一堆 API, 但不一定来得及马上把它们全部实现. 反过来, 你应该思考, 有没有更好的方法可以在你用到某个没有实现的函数的时候提醒你, 而不是让你经历一段没有必要的调试过程才发现竟然是个让你哭笑不得的原因呢? #pa

为了运行测试用例 `hello-str`, 你还需要实现库函数 `sprintf()`. 和其它库函数相比, `sprintf()` 比较特殊, 因为它的参数数目是可变的. 为了获得数目可变的参数, 你可以使用 C 库 `stdarg.h` 中提供的宏, 具体用法请查阅 `man stdarg`.

> [!edit] 实现 sprintf
> 
> 实现`abstract-machine/klib/src/stdio.c`中的`sprintf()`, 具体行为可以参考`man 3 printf`. 目前你只需要实现`%s`和`%d`就能通过`hello-str`的测试了, 其它功能(包括位宽, 精度等)可以在将来需要的时候再自行实现.

> [!sq] stdarg 是如何实现的?
> 
> `stdarg.h` 中包含一些获取函数调用参数的宏, 它们可以看做是调用约定中关于参数传递方式的抽象. 不同 ISA 的 ABI 规范会定义不同的函数参数传递方式, 如果让你来实现这些宏, 你会如何实现?

### 重新认识计算机: 计算机是个抽象层

我们在PA1中介绍了"程序在计算机上运行"的微观视角: 程序是个状态机. 状态机视角可以从指令层次精确地描述程序运行的每一处细节, 但这丢失了程序的语义. 对于一些简单的程序, 你还可以把状态机画出来, 但面对一些复杂的程序, 状态机视角就不能帮助我们了. 为了更好地理解复杂程序, 我们需要从一个新的视角来切入.

我们先来讨论在TRM上运行的程序, 我们对这些程序的需求进行分类, 来看看我们的计算机系统是如何支撑这些需求的.

|TRM|计算|内存申请|结束运行|打印信息|
|---|---|---|---|---|
|运行环境|-|malloc()/free()|-|printf()|
|AM API|-|heap|halt()|putch()|
|ISA接口|指令|物理内存地址空间|nemu_trap指令|I/O方式|
|硬件模块|处理器|物理内存|Monitor|串口|
|电路实现|fetch_decode_exec ()|pmem[]|nemu_state|serial_io_handler ()|

- 计算. 这是程序最基本的需求, 以至于它甚至不属于运行时环境和 AM 的范畴. 所有计算相关的代码 (顺序语句, 分支, 循环, 函数调用等), 都会被编译器编译成功能等价的指令序列, 最终在 CPU 上执行. 在 NEMU 中, 我们通过 `fetch_decode_exec()` 这个函数以及相应的辅助函数来实现"CPU 执行指令"的功能.
- 内存申请. 有的程序需要在运行时刻动态地申请内存来使用. 和 libc 类似, klib 提供了 `malloc()` 和 `free()` 来实现内存的动态管理 (你将来会实现它们), 它们又会使用 TRM 中提供的 API `heap` 来获得堆区的起始和末尾. 而 `heap` 的区间又是由 ISA-平台这个二元组对应的物理内存地址空间来决定的. 这一地址空间对应着物理内存的大小, 在 NEMU 中, 它就是大数组 `pmem[]` 的大小.
- 结束运行. 一般程序都会有结束运行的时候, TRM 提供了一个 `halt()` 的 API 来实现这一功能. 由于这个需求过于简单, 因此无需运行时环境提供更复杂的接口. `halt()` 的具体实现和 ISA 有关, 我们使用了人为添加的 `nemu_trap` 指令来实现这一点. 执行 `nemu_trap` 指令会让 NEMU 从 CPU 执行指令的循环中跳出, 返回到 Monitor 中, 这是通过设置 Monitor 中的一个状态变量 `nemu_state` 来实现的.
- 打印信息. 输出是程序的另一个基本需求. 程序可以调用 klib 中的 `printf()` 来输出, 它会通过 TRM 的 API `putch()` 来输出字符. 不同的 ISA-平台有不同的字符输出方式, 在$ISA-nemu 中, `putch()` 通过 I/O 相关的指令把字符写入到串口, 最终在 NEMU 中通过 `serial_io_handler()` 将字符打印到终端. 关于输入输出的更多细节会在 PA2的最后部分进行介绍.

> [!notice] "程序在计算机上运行"的宏观视角: 计算机是个抽象层
> 
> 在之前的PA中, 我们一直都在强调"程序是个状态机"这个微观视角, 让大家站在底层来理解这个状态机是如何工作的. 现在我们终于有机会向高层远眺, 来理解计算机是如何把底层的功能经过层层抽象, 最终支撑程序的运行.
> 
> 每一层抽象都有它存在的理由:
> 
> - 概念相同的一个硬件模块有着不同的实现方式, 比如处理器既可以通过 NEMU 中简单的解释方式来实现, 也可以通过类似 QEMU 中高性能的二进制翻译方式来实现, 甚至可以通过 verilog 等硬件描述语言来实现一个真实的处理器.
> - ISA是硬件向软件提供的可以操作硬件的接口
> - AM 的 API 对不同 ISA (如 x86/mips32/riscv32) 的接口进行了抽象, 为上层的程序屏蔽 ISA 相关的细节
> - 运行时环境可以通过对AM的API进行进一步的封装, 向程序提供更方便的功能
> 
> 这些抽象都是为了方便我们在各种各样的计算机系统中编写运行五花八门的程序, 你将要在 PA3中运行的仙剑奇侠传, 也都是通过层层抽象分解成最基本的硬件操作, 最后以状态机的方式来运行.


>[!abstract]
>PA 究竟在做什么?
>
>到此为止, 我们已经将 PA 中最重要的两个关于"程序在计算机上运行"的视角介绍完了:
>
>- 微观视角: 程序是个状态机
>- 宏观视角: 计算机是个抽象层
>
>PA 剩下的内容就是借鉴 AM 的启发, 按照计算机发展史的顺序给计算机硬件添加各种新特性, 并强化运行时环境的功能, 最后运行各种更复杂的程序. PA 会把添加新特性的过程作为案例, 让大家不断地从这两个视角来理解"程序如何在计算机上运行". 具体地, 在 PA2 的最后, 我们会添加 IOE 来实现一个冯诺依曼计算机系统; 在 PA3 中, 我们会添加 CTE, 来支持批处理系统的运行; 在最后的 PA4 中, 我们会添加 VME, 来运行一个简单又酷炫的分时多任务系统.
>
>我们在这里给出 PA 的一个全局概念图 (图中的"运行时环境"包含了 AM, klib, 甚至是 OS 和 libc), 这个图的三维坐标轴总结了 PA 中 3 个最重要的结论, 也向大家展示了 PA 构建计算机系统的全过程. 大家在做实验的时候也可以多多思考: 我现在写的代码究竟位于哪一个抽象层? 代码的具体行为究竟是什么? ![pa-concept](https://nju-projectn.github.io/ics-pa-gitbook/ics2020/images/pa-concept.png)