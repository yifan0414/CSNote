我们在上一小节中已经在概念上介绍了一条指令具体如何执行, 其中有的概念甚至显而易见得难以展开. 但当我们决定往 TRM 中添加各种高效指令的同时, 也意味着我们无法回避繁琐的细节.

首先你需要了解指令确切的行为, 为此, 你需要阅读生存手册中指令集相关的章节. 具体地, 无论你选择何种ISA, 相应手册中一般都会有以下内容, 尝试RTFM并寻找这些内容的位置:

- 每一条指令具体行为的描述
- 指令 opcode 的编码表格

特别地, 由于 x86的指令集的复杂性, 我们为选择 x86的同学提供了[一个简单的阅读教程](https://nju-projectn.github.io/ics-pa-gitbook/ics2020/i386-intro.html).

```ad-must
title: i386手册勘误

由于PDF版本的i386手册的印刷错误较多, 一定程度上影响理解, 我们在github上开放了一个[repo](https://github.com/NJU-ProjectN/i386-manual), 用于提供修复印刷错误的版本. 同时我们也为修复错误后的版本提供在线的[HTML版本](https://nju-projectn.github.io/i386-manual/toc.htm).

如果你在做实验的过程中也发现了新的错误, 欢迎帮助我们修复这些错误.
```

```ad-cloud
title: RISC - 与 CISC 平行的另一个世界

你是否觉得 x86指令集的格式特别复杂? 这其实是 CISC 的一个特性, 不惜使用复杂的指令格式, 牺牲硬件的开发成本, 也要使得一条指令可以多做事情, 从而提高代码的密度, 减小程序的大小. 随着时代的发展, 架构师发现 CISC 中复杂的控制逻辑不利于提高处理器的性能, 于是 RISC 应运而生. RISC 的宗旨就是简单, 指令少, 指令长度固定, 指令格式统一, 这和 KISS 法则有异曲同工之妙. [这里](http://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc)有一篇对比 RISC 和 CISC 的小短文.

另外值得推荐的是[这篇文章](http://blog.sciencenet.cn/blog-414166-763326.html), 里面讲述了一个从RISC世界诞生, 到与CISC世界融为一体的故事, 体会一下RISC的诞生对计算机体系结构发展的里程碑意义.
```

如果你非常幸运地选择了 riscv32, 你会发现目前只需要阅读很少部分的手册内容就可以了: 在 PA 中, riscv32的客户程序只会由 RV32I 和 RV32M 两类指令组成. 这得益于 RISC-V 指令集的设计理念 - 模块化.

```ad-cloud
title: RISC-V - 一款设计精巧的指令集

RISC-V 是一款非常年轻的指令集 - 第一版 RISC-V 是在2011年5月由 UC Berkeley 的研究团队提出的, 至今已经风靡全球. 开放性是 RISC-V 的最大卖点, 就连 ARM 和 MIPS 也都为之震撼, 甚至还因竞争关系而互撕... [这篇文章](http://blog.sciencenet.cn/blog-414166-1089206.html)叙述了 RISC-V 的理念以及成长的一些历史.

当然, 这些和处于教学领域的 PA 其实没太大关系. 关键是

- RISC-V 真的很简单.
- 简单之余, 还有非常多对程序运行深思熟虑的考量. 如果你阅读 RISC-V 的手册, 你就会发现里面阐述了非常多设计的推敲和取舍. 另外 David Patterson 教授 (因推广 RISC 而获得2018年的图灵奖, 可谓体系结构领域的一代宗师) 还为 RISC-V 的推广编写了一本入门书籍 [The RISC-V Reader](http://www.riscvbook.com/), 书中从系统的角度叙述了 RISC-V 大量的设计原则, 并与现有指令集进行对比, 非常值得一读. 中科院计算所的三位研究生为这本书编写了[中文翻译的版本](http://riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf) (其中一位也算是你们的直系师兄了), 不过由于这本书并没有跟进 RISC-V 官方手册的最新内容, 我们还是建议你阅读 RISC-V 的官方手册.
```

## RTFSC (2)

理解了上一小节的 YEMU 如何执行指令之后, 你就会对模拟器的框架有一个基本的认识了. NEMU 要模拟一个真实的 ISA, 因此代码要比 YEMU 复杂得多, 但其中蕴含的基本原理是和 YEMU 相同的. 下面我们来介绍 NEMU 的框架代码如何实现指令的执行.

在 RTFSC 的过程中, 你会遇到用于抽象 ISA 差异的大部分 API, 因此我们建议你先阅读[这个页面](https://nju-projectn.github.io/ics-pa-gitbook/ics2020/nemu-isa-api.html)来对这些 API 的功能进行基本的了解, 将来在代码中遇到它们的时候可以进行查阅.

我们在PA1中提到:

> 我们可以看到 `cpu_exec()` 模拟了 CPU 的工作方式: 不断执行指令. `isa_exec_once()` 函数 (在 `nemu/src/isa/$ISA/exec/exec.c` 中定义) 让 CPU 执行当前 PC 指向的一条指令, 然后更新 PC.

具体地, 在 `isa_exec_once()` 中, 代码首先定义了一个 `DecodeExecState` 类型的结构体变量 `s`, 它用于存放在执行一条指令过程中的译码和执行信息, 包括操作数的类型, 宽度, 值等信息. 还有一些信息是 ISA 相关的, NEMU 用一个结构类型 `ISADecodeInfo` 来对这些信息进行抽象, 具体的定义在 `nemu/include/isa/$ISA.h` 中. 代码对 `s` 进行一些必要的初始化之后, 就会将当前的 PC 保存 `s` 的成员 `seq_pc` 中, 这里的 `seq` 代表顺序 (sequential)的意思.

然后代码将 `s` 的地址作为参数送进 `fetch_decode_exec()` 函数 (在 `nemu/src/isa/$ISA/exec/exec.c` 中定义)中. 显然, `fetch_decode_exec()` 函数覆盖了指令周期的所有阶段: 取指, 译码, 执行, 在这些阶段中, 代码都可以对 `s` 进行记录和访问.

### 取指(instruction fetch, IF)

`fetch_decode_exec()` 做的第一件事情就是**取指令**. 在 NEMU 中, 有一个函数 `instr_fetch()` (在 `nemu/include/cpu/exec.h` 中定义)专门负责取指令的工作. `instr_fetch()` 最终会根据参数 `len` 来调用不同长度的 `vaddr_ifetch()` (在 `nemu/src/memory/paddr.c` 中定义). 在不同长度的 `vaddr_ifetch()` 函数中, 代码都会调用 `isa_vaddr_check()` 来检查这次取指是否可以直接访问物理内存. 目前 `isa_vaddr_check()` 的返回值都是 `MEM_RET_OK`, 因此最终都会通过 `paddr_read()` 来访问物理内存中的内容. **因此, 取指操作的本质只不过就是一次内存的访问而已.**

### 译码(instruction decode, ID)

译码的目的是得到指令的操作和操作对象, 这主要是通过查看指令的 `opcode` 来决定的. 不同 ISA 的 `opcode` 会出现在指令的不同位置, 我们只需要根据指令的编码格式, 从取出的指令中抽取出相应的 `opcode` 即可.

和 YEMU 类似, 取出 `opcode` 之后, 代码通过一个 `switch-case` 语句来进行操作码译码, 这个 `switch-case` 语句就充当了查找表的作用. 为了方便这个查找表的编写, 我们提供了一些宏 (在 `nemu/include/cpu/exec.h` 中定义), 例如 `IDEXW(0xb0, mov_I2r, mov, 1)` 展开之后结果为:

```c
case 0xb0: set_width(s, 1); decode_mov_I2r(s); exec_mov(s); break;
```

这和 YEMU 的代码是非常类似的.
```ad-cloud
title: 操作数宽度的处理

mips32 和 riscv32 的访存指令会有不同操作数宽度的版本, 包括 32 位, 16 位和 8 位, riscv64 还支持操作数宽度是 64 位的访存指令, 因此我们还需要把宽度信息记录到 `s` 中提供后续过程使用.

对于 x86 来说就更复杂了, 大部分指令都有不同操作数宽度的版本, 因此 x86 的操作数宽度信息记录会更复杂: 首先通过 `set_width()` 函数记录译码查找表中记录的操作数宽度; 若这一操作数宽度结果为 `0`, 表示仅仅根据操作码来判断, 操作数宽度还不能确定, 可能是 16 位或者 32 位, 需要通过 `s->isa.is_operand_size_16` 成员变量来决定. 这其实实现了"操作数宽度前缀"的相关功能, 更多说明请参考[这个例子](https://nju-projectn.github.io/ics-pa-gitbook/ics2020/exec.html).
```

刚才我们只是知道了指令的具体操作 (比如数据移动), 但我们还是不知道操作对象 (比如从哪里移动到哪里). 为了解决这个问题, 代码需要进行进一步的译码工作, 这是通过调用相应的 `译码辅助函数` (decode helper function)来完成的. 译码辅助函数统一通过宏 `def_DHelper` (在 `nemu/include/cpu/decode.h` 中定义)来定义:

```c
#define def_DHelper(name) void concat(decode_, name) (DecodeExecState *s)
```

每个译码辅助函数负责进行一种类型的操作数译码, 把指令中的操作数信息分别记录在译码信息 `s` 的 `src` 成员, `src2` 成员和 `dest` 成员中, 它们分别代表两个源操作数和一个目的操作数. `nemu/include/rtl/rtl.h` 中定义了三个宏 `id_src`, `id_src2` 和 `id_dest`, 用于方便地访问它们.

译码辅助函数的命名很直观, 直接反映了操作数的类型和数据流向. 以 `nemu/src/isa/x86/local-include/decode.h` 为例, 其中的译码辅助函数主要以 i386 手册附录 A 中的操作数表示记号来命名. 例如 `I2r` 表示将立即数移入寄存器, 其中 `I` 表示立即数, `2` 表示英文 `to`, `r` 表示通用寄存器, 更多的记号请参考 i386手册.

我们会发现, 类似寄存器和立即数这些操作数, 其实是非常常见的操作数类型. 为了进一步实现操作数译码和指令译码的解耦, 框架代码对这些操作数的译码进行了抽象封装, 指令译码过程由若干 `译码操作数辅助函数` (decode operand helper function)组成. 译码操作数辅助函数统一通过宏 `def_DopHelper` 来定义

```c
// nemu/src/isa/x86/local-include/decode.h
#define def_DopHelper(name) void concat(decode_op_, name) (DecodeExecState *s, Operand *op, bool load_val)
```

注意不同 ISA 的 `def_DopHelper` 定义会有不同. 以 x86为例, 译码操作数辅助函数会把操作数的信息记录在结构体 `op` 中, 如果操作数在指令中, 就会通过 `instr_fetch()` 将它们从 `s->seq_pc` 所指向的内存位置取出. 为了使译码操作数辅助函数更易于复用, 函数中将带有一个 `load_val` 参数, 用于控制是否需要将该操作数读出到译码信息 `s` 中供后续使用. 例如如果一个内存操作数是源操作数, 就需要将这个操作数从内存中读出来供后续执行阶段来使用; 如果它仅仅是一个目的操作数, 就不需要从内存读出它的值了, 因为执行这条指令并不需要这个值, 而是将新数据写入相应的内存位置.

```ad-cloud
title: x86的变长指令

由于CISC指令变长的特性, x86指令长度和指令形式需要一边取指一边译码来确定, 而不像RISC指令集那样可以泾渭分明地处理取指和译码阶段, 因此你会在x86的译码操作数辅助函数中看到`instr_fetch()`的操作.
```

```ad-sq
title: 立即数背后的故事

在 x86的译码操作数辅助函数中, 框架代码通过 `instr_fetch()` 函数获得指令中的立即数. 别看这里就这么一行代码, 其实背后隐藏着针对[字节序](http://en.wikipedia.org/wiki/Endianness)的慎重考虑. 我们知道 x86是小端机, 当你使用高级语言或者汇编语言写了一个32位常数 `0x1234` 的时候, 在生成的二进制代码中, 这个常数对应的字节序列如下 (假设这个常数在内存中的起始地址是 x):

~~~txt
x   x+1  x+2  x+3
+----+----+----+----+
| 34 | 12 | 00 | 00 |
+----+----+----+----+
~~~

而大多数 PC 机都是小端架构 (我们相信没有同学会使用 IBM 大型机来做 PA), 当 NEMU 运行的时候,

~~~c
imm = instr_fetch(pc, 4);
~~~

这行代码会将 `34 12 00 00` 这个字节序列原封不动地从内存读入 `imm` 变量中, 主机的 CPU 会按照小端方式来解释这一字节序列, 于是会得到 `0x1234`, 符合我们的预期结果.

Motorola 68k 系列的处理器都是大端架构的. 现在问题来了, 考虑以下两种情况:

- 假设我们需要将 NEMU 运行在 Motorola 68k 的机器上 (把 NEMU 的源代码编译成 Motorola 68k 的机器码)
- 假设我们需要把 Motorola 68k 作为一个新的 ISA 加入到 NEMU 中

在这两种情况下, 你需要注意些什么问题? 为什么会产生这些问题? 怎么解决它们?

事实上不仅仅是立即数的访问, 长度大于1字节的内存访问都需要考虑类似的问题. 我们在这里把问题统一抛出来, 以后就不再单独讨论了.
```

```ad-sq
title: 立即数背后的故事 (2)

mips32和riscv32的指令长度只有32位, 因此它们不能像x86那样, 把C代码中的32位常数直接编码到一条指令中. 思考一下, mips32和riscv32应该如何解决这个问题?
```

### 执行 (execute, EX)

译码过程结束之后, 接下来会调用相应的执行辅助函数 (execution helper function)来进行真正的执行操作. 执行辅助函数统一通过宏 `def_EHelper` (在 `nemu/include/cpu/exec.h` 中定义)来定义:

```c
#define def_EHelper(name) void concat(exec_, name) (DecodeExecState *s)
```

它们的名字是指令操作本身. 执行辅助函数通过 RTL 指令来描述指令真正的执行功能 ( RTL 指令将在下文介绍).

特别地, 对于 x86来说, 大部分计算指令都可以访问内存, 于是框架代码提供了 `operand_write()` 函数 (在 `nemu/src/isa/x86/local-include/decode.h` 中定义), 来根据目的操作数类型的不同, 决定是写入寄存器还是写入内存; 而对于 mips32和 riscv32, 访问内存只能通过特定的访存指令进行, 因此每条指令的目的操作数类型都是唯一的.

### 更新PC

为了更新 PC, 我们需要确定刚刚执行完的指令的长度. **事实上, 在 `instr_fetch()` 中, 每次取指都会更新它的 `pc` 参数, 而这个参数就是 `s->seq_pc`, 因此 `s->seq_pc` 将会随着取出的指令长度而增长.** 因此当代码从 `fetch_decode_exec()` 返回时, `s->seq_pc` 将会指向下一条静态指令的地址, 此时通过 `update_pc()` (在 `nemu/include/cpu/exec.h` 中定义)对 PC 进行更新即可. ^7o1b0i

>[!idea] 静态指令和动态指令
>在程序分析领域中, 静态指令是指程序代码中的指令, 动态指令是指程序运行过程中的指令. 例如对于以下指令序列
>```
>100: jmp 102
>101: add
>102: xor
>```
> `jmp` 指令的下一条静态指令是 `add` 指令, 而下一条动态指令则是 `xor` 指令.


上文已经把一条指令在 NEMU 中执行的流程进行了大概的介绍, 但还有少量的细节没有完全覆盖 (例如指令组的译码表), 这些细节就交给你来去尝试理解啦. 不过为了特别照顾选择 x86的同学, 我们还是准备了 [[x86的mov指令执行例子剖析|一个例子]] 来 RTFSC.

```ad-notice
title: 驾驭项目, 而不是被项目驾驭
你和一个项目的关系会经历4个阶段:

1. 被驾驭: 你对它一无所知
2. 一知半解: 你对其中的主要模块和功能有了基本的了解
3. 驾轻就熟: 你对整个项目的细节都了如指掌
4. 为你所用: 你可以随心所欲地在项目中添加你认为有用的功能

在PA中, 达到第二个阶段的主要手段是阅读讲义和代码, 达到第三个阶段的主要手段是独立完成实验内容和独立调试. 至于要达到第四个阶段, 就要靠你的主观能动性了: 代码还有哪里做得不够好? 怎么样才算是够好? 应该怎么做才能达到这个目标?

你毕业后到了工业界或学术界, 就会发现真实的项目也都是这样:

1. 刚接触一个新项目, 不知道如何下手
2. RTFM, RTFSC, 大致明白项目组织结构和基本的工作流程
3. 运行项目的时候发现有非预期行为(可能是配置错误或环境错误, 可能是和已有项目对接出错, 也可能是项目自身的bug), 然后调试. 在调试过程中, 对这些模块的理解会逐渐变得清晰.
4. 哪天需要你在项目中添加一个新功能, 你会发现自己其实可以胜任.

这说明了: **如果你一遇到bug就找大神帮你调试, 你失去的机会和能力会比你想象的多得多.**
```

```ad-cloud
title: 拦截客户程序访存越界的非法行为

你将来很可能会遇到客户程序访存越界的错误, NEMU 的框架代码一旦检测到这一行为就会直接 panic. 这一行为的检测已经极大地帮助你发现代码的问题了, 想象一下, 如果 NEMU 并未拦截这一error, 你可能会看到怎么样的 failure?
```

### 结构化程序设计

对于x86, 细心的你会发现以下规律:

- 对于同一条指令的不同形式, 它们的执行阶段是相同的. 例如 `add_I2E` 和 `add_E2G` 等, 它们的执行阶段都是把两个操作数相加, 把结果存入目的操作数.
- 对于不同指令的同一种形式, 它们的译码阶段是相同的. 例如 `add_I2E` 和 `sub_I2E` 等, 它们的译码阶段都是识别出一个立即数和一个 `E` 操作数.
- 对于同一条指令同一种形式的不同操作数宽度, 它们的译码阶段和执行阶段都是非常类似的. 例如 `add_I2E_b`, `add_I2E_w` 和 `add_I2E_l`, 它们都是识别出一个立即数和一个 `E` 操作数, 然后把相加的结果存入 `E` 操作数.

这意味着, 如果独立实现每条指令不同形式不同操作数宽度的辅助函数, 将会引入大量重复的代码. 需要修改的时候, 相关的所有辅助函数都要分别修改, 遗漏了某一处就会造成 bug, 工程维护的难度急速上升.

```ad-notice
title: Copy-Paste - 一种糟糕的编程习惯
事实上, 第一版 PA 发布的时候, 框架代码就恰恰是引导大家独立实现每一个辅助函数. 大家在实现指令的时候, 都是把已有的代码复制好几份, 然后进行一些微小的改动 (例如把 `<<` 改成 `>>`). 当你发现这些代码有 bug 的时候, 噩梦才刚刚开始. 也许花了好几天你又调出一个 bug 的时候, 才会想起这个 bug 你好像之前在哪里调过. 你也知道代码里面还有类似的 bug, 但你已经分辨不出哪些代码是什么时候从哪个地方复制过来的了. 由于当年的框架代码没有足够重视编程风格, 导致学生深深地陷入调试的泥淖中, 这也算是 PA 的一段黑历史了.

这种糟糕的编程习惯叫 Copy-Paste, 经过上面的分析, 相信你也已经领略到它的可怕了. 事实上, [周源源教授](https://cseweb.ucsd.edu/~yyzhou/)的团队在2004年就设计了一款工具 CP-Miner, 来自动检测操作系统代码中由于 Copy-Paste 造成的 bug. 这个工具还让周源源教授收获了一篇[系统方向顶级会议OSDI的论文](http://pages.cs.wisc.edu/~shanlu/paper/OSDI04-CPMiner.pdf), 这也是她当时所在学校 UIUC 史上的第一篇系统方向的顶级会议论文.

不过, 之后周源源教授发现, 相比于操作系统, 应用程序的源代码中 Copy-Paste 的现象更加普遍. 于是她们团队把 CP-Miner 的技术应用到应用程序的源代码中, 并创办了 PatternInsight 公司. 很多 IT 公司纷纷购买 PatternInsight 的产品, 并要求提供相应的定制服务, 甚至 PatternInsight 公司最后还被 VMWare 收购了.

这个故事折射出, 大公司中程序员的编程习惯也许不比你好多少, 他们也会写出 Copy-Paste 这种难以维护的代码. 但反过来说, 重视编码风格这些企业看中的能力, 你从现在就可以开始培养.
```

一种好的做法是把**译码**, **执行**和**操作数宽度**的相关代码分离开来, 实现<font color="#ff0000">解耦</font>, 也就是在程序设计课上提到的结构化程序设计. 在框架代码中, 实现译码和执行之间的解耦的是 `IDEXW()` 相关的宏, 它的宏展开结果会依次调用相应的**译码**和**执行**的辅助函数, 这样我们就可以分别编写译码和执行的辅助函数, 然后来进行组合了. 实现操作数宽度和译码, 执行这两者之间的解耦的是 `Operand` 结构体中的 `width` 成员, 它们记录了操作数宽度, 译码和执行的过程中会根据它们进行不同的操作, 通过同一份译码辅助函数和执行辅助函数实现不同操作数宽度的功能.

```ad-sq
title: 指令执行的共性部分

事实上, mips32 和 riscv32 也存在类似的规律. 尝试寻找这些规律, 并阅读 NEMU 中执行指令相关的代码, 梳理其中 ISA 无关和 ISA 相关的内容, 然后尝试理解为什么框架代码要这样设计.
```

为了易于使用, 框架代码中使用了一些宏, 我们在这里把相关的宏整理出来, 供大家参考.

|宏|含义|
|---|---|
|`nemu/include/macro.h`||
|`str(x)`|字符串`"x"`|
|`concat(x, y)`|token`xy`|
|`nemu/include/cpu/decode.h`||
|`def_DHelper(name)`|名为`decode_name`的译码辅助函数的原型说明|
|`nemu/src/isa/$ISA/local-include/decode.h`||
|`def_DopHelper(name)`|名为`decode_op_name`的译码操作数辅助函数的原型说明|
|`nemu/include/cpu/exec.h`||
|`def_EHelper(name)`|名为`exec_name`的执行辅助函数的原型说明|
|`print_asm(...)`|将反汇编结果的字符串打印到缓冲区`log_asmbuf`中|
|`suffix_char(width)`|操作数宽度`width`对应的后缀字符(仅x86使用)|
| `print_asm_template[1\|2\|3](instr)` |打印单/双/三目操作数指令 `instr` 的反汇编结果|

### 用 RTL 表示指令行为

我们知道, x86 指令作为一种 CISC 指令集, 不少指令的行为都比较复杂. 但我们会发现, i386手册会用一些更简单的操作来表示指令的具体行为. 这说明, 复杂的 x86指令还是能继续分解成一些更简单的操作的组合. mips32和 riscv32的少数较复杂指令也能够进一步进行分解. 如果我们先实现这些简单操作, 然后再用它们来实现指令, 不就可以进一步提高代码的复用率了吗?

在 NEMU 中, 我们使用 [RTL(寄存器传输语言)](https://en.wikipedia.org/wiki/Register_transfer_language) 来描述这些简单的操作. 下面我们对 NEMU 中使用的 RTL 进行一些说明, 首先是 RTL 寄存器的定义. 在 NEMU 中, RTL 寄存器统一使用 `rtlreg_t` 来定义, 而 `rtlreg_t` (在 `nemu/include/common.h` 中定义)其实只是一个 `word_t` 类型:

```
typedef word_t rtlreg_t;
```

在 NEMU 中, RTL 寄存器只有以下这些

- 不同 ISA 的通用寄存器 (在 `nemu/include/isa/$ISA.h` 中定义)
- `id_src`, `id_src2` 和 `id_dest` 中的操作数内容 `val` (在 `nemu/include/cpu/decode.h` 中定义).
- 临时寄存器 `s0, s1, s2` 和 `t0` (在 `nemu/include/rtl/rtl.h` 中定义)
- 零寄存器 `rz` (在 `nemu/src/monitor/cpu-exec.c` 中定义), 它的值总是0
- x86的ISA相关译码信息中的内存基地址`mbr`

有了 RTL 寄存器, 我们就可以定义 RTL 指令对它们进行的操作了. 在 NEMU 中, RTL 指令有两种.

一种是 RTL 基本指令 (在 `nemu/src/engine/interpreter/rtl-basic.h` 中定义), 它们的特点是不需要使用临时寄存器, 可以看做是 CPU 执行过程中最基本的操作. 不同的 ISA 都可以使用 RTL 基本指令, 因此它们属于 ISA 无关的代码. RTL 基本指令包括 (我们使用了一些简单的正则表达式记号):

- 寄存器-寄存器类型和寄存器-立即数类型的基本算术/逻辑运算, 包括 `rtl_(add|sub|and|or|xor|shl|shr|sar|setrelop)i?`, 它们的定义用到了 `nemu/src/engine/interpreter/c_op.h` 中的 C 语言运算和 `interpret_relop()` 函数
- 寄存器-寄存器类型的乘除法运算, 包括 `rtl_i?(mul_[lo|hi]|div_[q|r])`,
- 被除数为64位的除法运算 `rtl_i?div64_[q|r]`
- guest 内存访问 `rtl_lm`, `rtl_lms` 和 `rtl_sm`
- host 内存访问 `rtl_host_lm` 和 `rtl_host_sm`
- 跳转, 包括直接跳转 `rtl_j`, 间接跳转 `rtl_jr` 和条件跳转 `rtl_jrelop`
- 终止程序 `rtl_exit` (在 `nemu/src/monitor/cpu-exec.c` 中定义)

```ad-cloud
title: 64位ISA特有的RTL基本指令

如果你选择了riscv64, 上述寄存器操作相关的RTL基本指令是针对64位位宽的, 为了方便进行32位数据的处理, 框架代码还额外提供了32位位宽的RTL基本指令:

- 32位寄存器-寄存器类型的基本算术/逻辑运算, 包括`rtl_(add|sub|shl|shr|sar)w`
- 32位寄存器-立即数类型的基本算术/逻辑运算, 包括`rtl_(add|shl|shr|sar)iw`
- 32位寄存器-寄存器类型的乘除法运算, 包括`rtl_mulw`和`rtl_(div|rem)u?w`

这些RTL基本指令的语义和相应的riscv64指令非常类似, 具体可以参考riscv手册.
```

```ad-cloud
title: RTL指令和二进制翻译

我们参考riscv指令的语义来定义RTL基本指令的行为, 恰恰体现了riscv指令集的简单. 那么, 既然我们能用RTL指令来表示x86指令的行为, 是不是也有可能用类似的riscv指令来模拟一条x86指令的行为呢?

这就是[二进制翻译](https://en.wikipedia.org/wiki/Binary_translation)的基本想法, [QEMU](https://www.qemu.org/)就是这样工作的! 当然不仅仅是用riscv指令来模拟x86指令, 用x86指令来模拟riscv指令也是可以的, 甚至所有指令集之间都能相互模拟, 因为理论上指令集的定义就是图灵完备的. 所以当你在x86的机器中运行`riscv32-qemu`时, 对于客户程序的每一条riscv32指令, QEMU都会生成若干条x86指令, 当x86真机执行了这些x86指令, 就相当于完成了客户程序中相应的riscv32指令的功能.
```

```ad-sq
title: 神秘的 host 内存访问 (建议二周目思考)

为什么需要有 host 内存访问的 RTL 指令呢?
```

第二种 RTL 指令是 RTL 伪指令, 它们是通过 RTL 基本指令或者已经实现的 RTL 伪指令来实现的. RTL 伪指令又分两类, 包括:

- ISA 无关的 RTL 伪指令 (在 `nemu/include/rtl/pseudo.h` 中定义), 主要包括一些常用的功能, 如立即数读入 `rtl_li`, 寄存器传输 `rtl_mv`, 按位取反 `rtl_not`, 符号扩展 `rtl_sext` 等, 用于方便 RTL 的编写
- ISA 相关的 RTL 伪指令 (在 `nemu/src/isa/$ISA/local-include/rtl.h` 中定义), 主要包括 ISA 相关性较强的功能 (如 x86的通用寄存器访问 `rtl_lr` 和 `rtl_sr`, 溢出和进/借位判断, EFLAGS 标志位访问等)

其中大部分 RTL 伪指令还没有实现, 必要的时候你需要实现它们. 有了这些 RTL 指令之后, 我们就可以方便地通过若干条 RTL 指令来实现每一条指令的行为了.

```ad-cloud
title: 小型调用约定
我们定义 RTL 基本指令的时候, 约定了 RTL 基本指令不需要使用 RTL 临时寄存器. 但某些 RTL 伪指令需要使用临时寄存器存放中间结果, 才能实现其完整功能. 这样可能会带来寄存器覆盖的问题, 例如如下 RTL 指令序列:

~~~
(1) rtl_mv(s, t0, s1);
(2) rtl_sext(s, s1, s0, 1);  // use t0 temporarily
(3) rtl_add(s, s0, t0, s2);
~~~

如果实现 `(2)` 的时候恰好使用到了 `t0` 作为临时寄存器, 在 `(3)` 中使用的 `t0` 就不再是 `(1)` 的结果了, 从而产生非预期的结果.

为了尽可能避免上述问题, 我们约定以下两条规则:

- 实现 RTL 伪指令的时候, 尽可能不使用 `dest` 之外的寄存器存放中间结果. 由于 `dest` 最后会被写入新值, 其旧值肯定要被覆盖, 自然也可以安全地作为 RTL 伪指令的临时寄存器.
- 实在需要使用临时寄存器的时候, 按照以下约定来使用:
    - `t0`, `t1`, ... - 只能在 RTL 伪指令的实现过程中存放中间结果
    - `s0`, `s1`, ... - 只能在译码辅助函数和执行辅助函数的实现过程中存放中间结果

仔细体会上述约定, 你也许会发现, 这和课上学习的[调用约定(calling convention)](https://en.wikipedia.org/wiki/Calling_convention) 有那么一点点相似之处. 如果把 RTL 指令看成一个函数调用, 我们刚才其实在讨论, 在这个"函数"里面究竟可以使用哪些 RTL 寄存器. 在调用约定中, 有些寄存器对被调用函数来说, 使用它们之前是需要先保存的. 但我们的 RTL 编程模型中并没有"栈"的概念, 所以在 RTL 中我们就不设置所谓的"被调用者保存寄存器"了. 从某种程度上来说, 这样的"小型调用约定"很难支撑大规模 RTL 指令的编写. 不过幸好, 在用 RTL 来实现指令的时候, 这一"小型调用约定"已经足够使用了.
```

```ad-notice
title: 计算机系统中的约定与未定义行为
上述例子其实折射出计算机系统工作的一种基本原则: 遵守约定.

我们定义了 RTL 寄存器和相应的 RTL 指令, 基于这些定义, 原则上可以编写出任意的 RTL 指令序列, 这些 RTL 序列最终也会按照它们原本的语义来执行. 但光靠这些定义, 我们无法避免上述 RTL 寄存器相互覆盖造成错误的问题. 所以我们又提出一些新的约定, 来避免这个问题. 当然, 你也可以自己提出一套新的约定 (比如把 `t0` 和 `s0` 的用法互换).

违反约定会发生什么呢? 最常见的就是程序无法得到正确的结果. 比如当两套约定不兼容的 RTL 代码放在一起的时候, 它们都分别违反了对方的约定 (你的 RTL 覆盖了我的 `t0`, 我的 RTL 覆盖了你的 `s0`). 当然也有可能恰好没有覆盖各自约定使用的寄存器, 撞大运地得到正确的运行结果. 总之, 违反约定的具体行为会怎么样, 还需要具体问题具体分析, 很难明确地说清楚.

既然说不清楚, 那就干脆不说吧, 于是有了[未定义行为(UB, Undefined Behavior)](https://en.wikipedia.org/wiki/Undefined_behavior)的概念: 只要遵守约定, 就能保证程序具有遵守约定后的特性; 如果违反, 不按照说好的来, 那就不保证行为是正确的.

计算机系统就是这样工作的: 计算机系统抽象层之间的接口其实也是一种约定, 比如指令就是软件和硬件的一种接口, 所以有了 ISA 手册来规范每一条指令的行为.

- 一方面, 编译器需要根据 ISA 手册中的约定来生成可以正确执行的代码. 如果编译器不按照手册约定来生成代码, 那么编译出的程序的行为就是未定义的.
- 另一方面, 硬件开发者也需要根据 ISA 手册中的约定来设计可以正确执行指令的处理器. 如果处理器不按照手册约定来执行指令, 处理器运行程序的行为就是未定义的.

引入未定义行为还有一个好处是, 给约定的实现方式带来一定的自由度. 例如, C 语言标准规定, 整数除法的除数为0时, 结果是未定义的. x86的除法指令在检测到除数为0时, 就会向 CPU 抛出一个异常信号. 而 MIPS 的除法指令则更简单暴力: 首先在 MIPS 指令集手册中声明, 除数为0时, 结果未定义; 然后在硬件上实现除法器电路的时候, 对除0操作就可以视而不见了. 然而给定一个除法器电路, 就算除数为0, 电路的输出也总会有一个值, 至于具体的值是什么, 就看造化了. 反正 C 语言标准规定除0的行为本身就是未定义的, 让除法指令随便返回一个值, 也不算违反 C 语言标准的约定.

未定义行为其实离你很近. 比如野指针的解引用, 会发生什么完全无法预料. 还有你经常使用的 `memcpy()`, 如果源区间和目的区间有重叠时, 它的行为会怎么样? 如果你从来没有思考过这个问题, 你应该去 `man` 一下, 然后思考一下为什么会这样. 还有一种有人欢喜有人愁的现象是基于未定义行为的编译优化: 既然源代码的行为是未定义的, 编译器基于此进行各种奇葩优化当然也不算违反约定. [这篇文章](https://homes.cs.washington.edu/~akcheung/papers/apsys12.pdf)列举了一些让你大开眼界的花式编译优化例子, 看完之后你就会刷新对程序行为的理解了.

**所以这就是为什么我们强调要学会 RTFM.** RTFM 是了解接口行为和约定的过程: 每个输入的含义是什么? 查阅对象的具体行为是什么? 输出什么? 有哪些约束条件必须遵守? 哪些情况下会报什么错误? 哪些行为是 UB? 只有完全理解并遵守它们, 才能正确无误地使用查阅的对象, 大至系统设计原则, 小到一个 `memcpy()` 的行为, 都蕴含着约定与遵守的法则. 理解这些法则, 也是理解计算机系统的不二途径.
```

```ad-cloud
title: UB, 编译优化和 datalab

听闻大班的 lab1 (datalab)曾经因为使用了 debian10的新版 gcc 而翻车. 后来了解到, 是因为 datalab 的参考代码中含有 int 整数溢出的 UB, debian 10的 gcc 利用了该 UB 进行编译优化, 导致参考代码生成了错误的参考答案.

C 语言标准规定, int 整数溢出的行为是未定义的, 但大部分程序员并不知道这一约定, 甚至连市面上流行的 C 语言教科书都认为 int 整数溢出的结果是 wrap around. datalab 是 CMU 设计的实验, 但原作者也会编写出含有 UB 的代码, 说明原作者对 UB 的理解也并未到位. 在旧版本的编译器中, 这些 UB 均未被触发. 但 UB 毕竟是 UB, 只能说明作者写代码的时候没有充分理解 C 语言标准.

[这篇论文](http://www.cs.utah.edu/~regehr/papers/overflow12.pdf)对整数溢出的分类和行为进行了梳理, 并且在实际应用中找出了大量整数溢出的例子进行分析, 推荐大家阅读. 论文中提到有一个被广泛应用 (包括 Office 和 Windows)的函数库 SafeInt 用于避免整数溢出, 但这个函数库自身的代码就被论文作者检测出整数溢出导致的 UB.

这些例子给我们的启示是: 我们不仅需要编写通过测试的代码, 而且需要编写符合语言规范的 well-defined 的代码. 退一步讲, 人毕竟会犯错误, 但我们至少要在出错的时候知道, 什么才是对的.
```

```ad-sq
title: RTL 寄存器中值的生存期

在程序设计课上, 我们知道 C 语言中不同的变量有不同的生存期: 有的变量的值会一直持续到程序结束, 但有的变量却很快消亡. 在上述定义的 RTL 寄存器中, 其实也有不同的生存期. 尝试根据生存期给 RTL 寄存器分类.

尽管目前这个分类结果并没有什么用处, 但其实将来在 PA5中设计 RTL 优化方案的时候, 生存期的性质会给我们提供很大的优化机会.
```

为了提高性能, 我们在 `Operand` 结构体中定义了一个 RTL 寄存器的指针 `preg`, 用于直接指向那些已经存在的 RTL 寄存器. 例如如果在进行译码的时候发现操作数是 `eax` 寄存器, **那么只需要通过让 `preg` 指向 `cpu.eax`, 将来就可以直接通过 `preg` 来访问到正确的操作数了, 而不需要通过 `rtl_mv()` 来将 `cpu.eax` 读到别处, 从而避免引入额外的开销.** 框架代码提供了 `dsrc1`, `dsrc2` 和 `ddest` 这三个宏, 分别用于方便地访问 `id_src1`, `id_src2` 和 `id_dest` 对应的 `preg`. ^6cbfx4

虽然使用指针可以提高性能, 但也会有以下几点需要注意:

- 如果源操作数是一个立即数, 那么它就没有 RTL 寄存器可以被 `preg` 来指向. 此时译码过程会通过 `rtl_li` 将立即数读入到操作数结构体 `Operand` 的 `val` 成员, 然后再让 `preg` 指向 `val`.
- 如果源操作数是 x86寄存器的字节或半字访问, 那么其类型并不是一个完整的 `rtlreg_t`, 不能直接被 `preg` 指向. 此时译码过程会通过 `rtl_lr` 将相应的值读入到操作数结构体 `Operand` 的 `val` 成员, 然后再让 `preg` 指向 `val`.
- 如果目标操作数是 mips32或者 riscv32的0号寄存器, 那么执行过程中可能会将结果写入了0号寄存器, 下次将会从0号寄存器中读出非0内容, 从而违反了 ISA 手册的规定. 为了修复这个问题, 在 mips32和 riscv32的 `isa_exec_once()` 函数中执行完一条指令后, 都会调用 `reset_zero()` 函数来将0号寄存器重新设置为0.
- 一般来说源操作数是不应该被修改的, 如果你打算把`dsrc1`或者`dsrc2`作为RTL指令的`dest`, 你需要确认这是否符合指令本身的语义.
- 如果一条指令的源操作数和目的操作数一样, 你可能需要注意一些RTL指令之间的顺序.

如果你理解不了上面的注意事项, 不必担心, 你可以把编写 RTL 作为一次指针的练习, 遇到问题的时候你就会对指针有更加深刻的理解了.

### 实现新指令

对译码, 执行和操作数宽度的解耦实现以及 RTL 的引入, 对在 NEMU 中实现客户指令提供了很大的便利, 为了实现一条新指令, 你只需要

1. 在 `exec.c` 的 `switch-case` 语句中填写正确的译码辅助函数, 执行辅助函数以及操作数宽度
2. 用RTL实现正确的执行辅助函数, 需要注意使用RTL伪指令时要遵守上文提到的小型调用约定

```ad-cloud
title: 感觉RTL临时寄存器不够用了?

其实是存在够用的实现方式的, 你可以尝试挑战一下这个目标. 当然, 如果实在坚持不了的话, 你也可以定义更多的 RTL 临时寄存器, 如 `t1`, `t2`, `s3`...

事实上, 如果定义了过多的 RTL 临时寄存器, 可能会对 PA5的性能优化带来一些负面影响. 不过 PA5并不记入成绩, 所以你也不用为此感到担忧.

框架代码定义了一些译码辅助函数和执行辅助函数, 你可以很方便地使用它们.
```

```ad-idea
title: 偏心的框架代码

这个"一些"对不同的 ISA 来说, 还是有很大差别的: 对 x86来说其实是"绝大部分", 而对 mips32和 riscv32来说其实是"少量".

你应该能感受到, 这节讲义内容为 x86提供了很多帮助, 而对 mips32和 riscv32的提示却很少, 甚至提供的框架代码也非常寒酸. 你也许会觉得这是 yzh 偏心, 但其实这恰恰反衬出 x86的复杂 (看看不同 ISA 的手册就知道了). 考虑到公平性, 选择 mips32和 riscv32的同学则需要独立编写大部分的译码辅助函数 (其实很少, 因为 RISC 指令集的格式都比较规整)和执行辅助函数 (其实很简单, 因为 NEMU 中的 RTL 就是参考 riscv 来定义的, 也可以看成是一种 RISC 指令集). 我们希望无论选择你何种 ISA, 为了获取相同的分数, 你都需要付出一定的努力. 如果你对公平性有更好的建议, 请联系 yzh.

你可以与选择不同 ISA 的同学交流, 我们也鼓励你在二周目的时候选择不同的 ISA 进行新的攻略, 这样你也许就能对不同 ISA 之间的区别有更深刻的体会了.
```

如果你读过上文的扩展阅读材料中关于 RISC 与 CISC 融为一体的故事, **你也许会记得 CISC 风格的 x86指令最终被分解成 RISC 风格的微指令在计算机中运行, 才让 x86在这场扩日持久的性能大战中得以存活下来的传奇.** NEMU 在经历了第二次重构之后, 也终于引入了 RISC 风格的 RTL 来实现指令, 这也许是冥冥之中的安排吧.

```ad-edit
title: RTFSC 理解指令执行的过程

这一小节的细节非常多, 你可能需要多次阅读讲义和代码才能理解每一处细节. 根据往届学长学姐的反馈, 一种有效的理解方法是通过做笔记的方式来整理这些细节. 事实上, 配合 GDB 食用效果更佳.

为了避免你长时间对代码的理解没有任何进展, 我们就增加一道必答题吧:

> 请整理一条指令在 NEMU 中的执行过程.

除了 `device` 相关以及一些未实现的功能 (如 `intr.c` 和 `mmu.c`), NEMU 的其它代码你都已经有能力理解了. 因此不要觉得讲义中没有提到的文件就不需要看, 尝试尽可能地理解每一处细节吧! 在你遇到 bug 的时候, 这些细节就会成为帮助你调试的线索.
```

## 运行第一个 C 程序

说了这么多, 现在到了动手实践的时候了. 首先克隆一个新的子项目 `am-kernels`, 里面包含了一些测试程序:

```bash
cd ics2020
bash init.sh am-kernels
```

你在 PA2的第一个任务, 就是实现若干条指令, 使得第一个简单的 C 程序可以在 NEMU 中运行起来. 这个简单的 C 程序是 `am-kernels/tests/cpu-tests/tests/dummy.c`, 它什么都不做就直接返回了.

```ad-edit
title: 准备交叉编译环境

如果你选择的 ISA 不是 x86, 你还需要准备相应的 gcc 和 binutils, 才能正确地进行编译.

- mips32
    - `apt-get install g++-mips-linux-gnu binutils-mips-linux-gnu`
- riscv32(64)
    - `apt-get install g++-riscv64-linux-gnu binutils-riscv64-linux-gnu`
    - 如果你选择的是 riscv32, 则需要使用 sudo 权限修改以下文件:

~~~git
--- /usr/riscv64-linux-gnu/include/bits/wordsize.h
+++ /usr/riscv64-linux-gnu/include/bits/wordsize.h
@@ -25,5 +25,5 @@
 #if __riscv_xlen == 64
 # define __WORDSIZE_TIME64_COMPAT32 1
 #else
-# error "rv32i-based targets are not supported"
+# define __WORDSIZE_TIME64_COMPAT32 0
 #endif
~~~
```

在 `am-kernels/tests/cpu-tests/` 目录下键入

```bash
make ARCH=$ISA-nemu ALL=dummy run
```

>[!hint] 在 `nemu.mk` 中取消批处理模式
>
>```git
>diff --git a/abstract-machine/scripts/platform/nemu.mk b/abstract-machine/scripts/platform/nemu.mk
>index 853dd68..eb0446f 100644
>--- a/abstract-machine/scripts/platform/nemu.mk
>+++ b/abstract-machine/scripts/platform/nemu.mk
>@@ -14,7 +14,7 @@ CFLAGS    += -fdata-sections -ffunction-sections
> LDFLAGS   += -L $(AM_HOME)/am/src/nemu/scripts
> LDFLAGS   += -T $(AM_HOME)/am/src/nemu/isa/$(ISA)/boot/loader.ld
> LDFLAGS   += --gc-sections -e _start
>-NEMUFLAGS += -b -l $(shell dirname $(IMAGE).elf)/nemu-log.txt $(IMAGE).bin
>+NEMUFLAGS += -l $(shell dirname $(IMAGE).elf)/nemu-log.txt $(IMAGE).bin
>```

编译 `dummy` 程序, 并启动 NEMU 运行它. 事实上, 并不是每一个程序都可以在 NEMU 中运行, **`abstract-machine` 子项目专门用于编译出能在 NEMU 中运行的程序**, 我们在下一小节中会再来介绍它.

在 NEMU 中运行 `dummy` 程序, 你会发现 NEMU 输出以下信息 (以 x86为例):

```
invalid opcode(pc = 0x0010000a): e8 05 00 00 00 90 31 c0 ...

There are two cases which will trigger this unexpected exception:
1. The instruction at pc = 0x0010000a is not implemented.
2. Something is implemented incorrectly.
Find this pc value(0x0010000a) in the disassembling result to distinguish which case it is.

If it is the first case, see
 _ ____   ___    __    __  __                         _ 
(_)___ \ / _ \  / /   |  \/  |                       | |
 _  __) | (_) |/ /_   | \  / | __ _ _ __  _   _  __ _| |
| ||__ < > _ <| '_ \  | |\/| |/ _  | '_ \| | | |/ _  | |
| |___) | (_) | (_) | | |  | | (_| | | | | |_| | (_| | |
|_|____/ \___/ \___/  |_|  |_|\__,_|_| |_|\__,_|\__,_|_|

for more details.

If it is the second case, remember:
* The machine is always right!
* Every line of untested code is always wrong!
```

这是因为你还没有实现以 `0xe8` 为首字节的指令, 因此, 你需要开始在 NEMU 中添加指令了.

```ad-sq
title: 为什么执行了未实现指令会出现上述报错信息

RTFSC, 理解执行未实现指令的时候, NEMU具体会怎么做.
```

```ad-idea
title:我选择 x86, 但出错信息中显示的字节序列有所不同

这很可能是你选择了其它Linux发行版, 由于gcc版本的差异导致的. 此时按照你的gcc编译结果来实现指令即可.
```

要实现哪些指令才能让 `dummy` 在 NEMU 中运行起来呢? 答案就在其反汇编结果 ( `am-kernels/tests/cpu-tests/build/dummy-$ISA-nemu.txt` )中. 以 x86为例, 查看反汇编结果, 你发现只需要添加 `call`, `push`, `sub`, `xor`, `ret` 五条指令就可以了. 每一条指令还有不同的形式, 根据 KISS 法则, 你可以先实现只在 `dummy` 中出现的指令形式, 通过指令的 `opcode` 可以确定具体的形式.

```ad-idea
title: 交叉编译工具链

如果你选择的ISA不是x86, 在查看客户程序的二进制信息(如`objdump`, `readelf`等)时, 需要使用相应的交叉编译版本, 如`mips-linux-gnu-objdmup`, `riscv64-linux-gnu-readelf`等.
```

```ad-idea
title:去除 endbr32指令

经测试, 如果系统的 CPU 版本比较新 (如在十代酷睿), 在 Ubuntu20.04上会默认编译出 endbr32指令. 如果你属于这种情况, 请参考[这里](https://github.com/NJU-ProjectN/abstract-machine/commit/0f6f91dee305ad0b143bf13becc2882eda4d977a)添加相应的编译选项来去掉这条新指令, 添加后, 在 `am-kernels/tests/cpu-tests/` 目录下执行 `make clean`, 并在 `abstract-machine/` 目录下执行 `make clean-all`, 然后重新编译即可.
```

这里要再次强调, **你务必通过 RTFM 来查阅指令的功能, 不能想当然. 手册中给出了指令功能的完整描述 (包括做什么事, 怎么做的, 有什么影响), 一定要仔细阅读其中的每一个单词, 对指令功能理解错误和遗漏都会给以后的调试带来巨大的麻烦.**

```ad-idea
title:再提供一些 x86的提示吧

- `call`: `call` 指令有很多形式, 不过在 PA 中只会用到其中的几种, 现在只需要实现 `CALL rel32` 的形式就可以了. 至于跳转地址, 框架代码里面已经有不少提示了, 也就算作是 RTFSC 的一个练习吧.
- `push`: 现在只需要实现 `PUSH r32` 和 `PUSH imm32` 的形式就可以了, 它们可以很容易地通过 `rtl_push` 来实现
- `sub`: 在实现 `sub` 指令之前, 你首先需实现 EFLAGS 寄存器. 你只需要在寄存器结构体中添加 EFLAGS 寄存器即可. EFLAGS 是一个32位寄存器, 但在 NEMU 中, 我们只会用到 EFLAGS 中以下的5个位: `CF`, `ZF`, `SF`, `IF`, `OF`, 它们的功能可暂不实现. 关于 EFLAGS 中每一位的含义, 请查阅 i386手册. 实现了 EFLAGS 寄存器之后, 再实现相关的 RTL 指令, 之后你就可以通过这些 RTL 指令来实现 `sub` 指令了
- `xor`, `ret`: RTFM吧
```

```ad-edit
title:运行第一个客户程序

在 NEMU 中通过 RTL 指令实现上文提到的指令, 具体细节请务必参考手册. 实现成功后, 在 NEMU 中运行客户程序 `dummy`, 你将会看到 `HIT GOOD TRAP` 的信息. 如果你没有看到这一信息, 说明你的指令实现不正确, 你可以使用 PA1中实现的简易调试器帮助你调试.
```

>[!abstract] 温馨提示
> PA2阶段1到此结束.