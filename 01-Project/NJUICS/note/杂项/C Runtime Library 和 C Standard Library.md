# 1 C Runtime Library

任何一个 C 程序，它的背后都有一套庞人的代码来进行支撑，以使得该程序能够正常运行。这套代码至少包括入口函数，及其所依赖的函数所构成的函数集合。当然，它还理应包括各种标准库函数的实现。

这样的一个代码集合称之为运行时库 (Runtime Library)。而 C 语言的运行库，即被称为 C 运行库 (CRT)。

如果读者拥有 Visual Studio，可以在 VC/crt/src 里找到一份 C 语言运行库的源代码。然而，由于此源代码过于庞大，仅仅。c 文件就有近千个，并且和 C++的 STL 代码一起毫无组织地堆放在一起，以至于实际上没有什么仔细阅读的可能性。同样，Liux 下的 libc 源代码读起来也如同啃砖头。所幸的是，在本章的最后，我们会一起来实现一个简单的运行库，让大家更直观地了解它。

一个 C 语言运行库大致包含了如下功能:

- **启动与退出**：包括入口函数及入口函数所依赖的其他函数等。
- 标准函数: 由 C 语言标准规定的 C 语言标准库所拥有的函数实现。
- I/O: I/O 功能的封装和实现, 参见上一节中 I/O 初始化部分。
- **堆**: 堆的封装和实现, 参见上一节中堆初始化部分。
- 语言实现：语言中一些特殊功能的实现。
- 调试：实现调试功能的代码。

在这些运行库的组成部分中，**C 语言标准库占据了主要地位并且大有来头**。C 语言标准库是 C 语言标准化的基础函数库，我们平时使用的 printf、exit 等都是标准库中的一部分。标准库定义了 C 语言中普遍存在的函数集合，我们可以放心地使用标准库中规定的函数而不用担心在将代码移植到别的平台时对应的平台上不提供这个函数。在下一章节里，我们会介绍 C 语言标准库的函数集合，并对一些特殊的函数集合进行详细介绍。

# 2 C Standard Library

在本章节里，我们将介绍 C 语言标准库的基本函数集合，并对其中一些特殊函数进行详细的介绍。ANSI C 的标准库由 24 个 C 头文件组成。与许多其他语言（如 Java）的标准库不同，C 语言的标准库非常轻量，它仪仅包含了数学函数、字符字符串处理，I/O 等基本方面，例如：

- 标准输入输出（stdio.h）
- 文件操作（stdio.h）
- 字符操作（ctype.h）
- 字符串操作（string.h）
- 数学函数（math.h）
- 资源管理（stdlib.h）
- 格式转换（stdlib.h）
- 时间/日期（time.h）
- 断言（assert.h）
- 各种类型上的常数（limits.h & float.h）

除此之外，C 语言标准还有一些特殊的库，用于执行一些特殊的操作，例如：

- 变长参数（stdarg.h）
- 非局部跳转（setjmp.h）



# 3 glibc

>[!must] C 运行库的自举 
>我们知道 C 运行库直接负责程序的启动入口和一些初始化的内容以及一些库函数，那么这个从 0 到 1 的过程是怎么样的呢？考虑以下问题：
> 1. 如果没有 glibc 源代码所编译生成的 libc 库文件（crt1.o crti.o crtn.o）。程序应该如何执行？如何返回呢？（这涉及到 glibc 的诞生）
> 2. 假设库函数中没有 printf 函数，我们应该如何添加 
>
>>[!idea] 层层抽象，库函数位于操作系统之上，使用操作系统所提供的功能（系统调用），抽象为更简单的形式
>
>>[!question] 我们知道C语言的库函数使用了操作系统所提供的系统调用，那么其他语言是如何实现库函数的呢?
>>
>>其他编程语言实现库函数的方式与C语言非常类似，通常也是通过调用操作系统提供的系统调用接口，或者调用低层次的库函数（例如C语言的库函数）。让我们来看几个具体的例子：
>>
>>1. **Python**：Python的标准库包含许多高层次的功能，例如文件操作、网络编程、数据库访问等。这些功能的底层实现通常是通过调用C语言的库函数，这些C语言的函数会调用操作系统的系统调用。例如，Python的`open`函数在底层调用了C语言的`fopen`函数。
>>
>>2. **Java**：Java的标准库（Java API）提供了大量的功能，包括文件操作、网络编程、图形用户界面等。这些功能的底层实现通常是通过Java的本地接口（JNI）调用C或C++的库函数。例如，Java的`System.out.println`函数在底层调用了C语言的`printf`函数。
>>
>>3. **JavaScript**：JavaScript的运行环境（如浏览器或Node.js）提供了许多功能，包括DOM操作、网络请求、文件操作（在Node.js中）等。这些功能的底层实现通常是通过调用C或C++的库函数，或者直接调用操作系统的系统调用。例如，Node.js的`fs.readFile`函数在底层调用了C语言的`read`函数。
>>
>>总的来说，不同的编程语言可能有各自不同的方式来实现库函数，但是最终都需要依赖于操作系统提供的系统调用，或者依赖于低层次的库函数（如C语言的库函数）。这是因为操作系统提供的系统调用是访问硬件资源（如CPU、内存、磁盘、网络）的唯一方式。

- [ ] 解释下 glibc 的编译过程 #pa/todo

运行库是平台相关的，因为它与操作系统结合得非常紧密。C 语言的运行库从某种程度上来讲是 C 语言的程序和不同操作系统平台的**抽象层**，它将不同的操作系统 API 抽象成相同的库函数。**比如我们可以在不同的操作系统平台下使用 fread 来读取文件，而事实上 fread 在不同的操作系统平台下的实现是不同的，但作为运行库的使用者我们不需要关心这一点**。虽然各个平台下的 C 语言运行库提供了很多功能，但很多时候它们毕竟有限，比如用户的权限控制、操作系统线程创建等都不是属于标准的 C 语言运行库（ #c ）。于是我们不得不通过其他的办法，诸如绕过 C 语言运行库直接调用操作系统 API 或使用其他的库。Linux 和 Windows 平台下的两个主要 C 语言运行库分别为 glibc (GNU C Library)和 MSVCRT (Microsoft Visual C Run-time)，我们在下面将会分别介绍它们。

值得注意的是，像线程操作这样的功能并不是标准的 C 语言运行库的一部分，但是 glibc 和 MSVCRT 都包含了线程操作的库函数。比如 glibc 有一个可选的 pthread 库中的 `pthread_create()` 函数可以用来创建线程；而 MSVCRT 中可以使用 `_beginthread()` 函数来创建线程。所以 glibc 和 MSVCRT 事实上是标准 C 语言运行库的**超集**，它们各自对 C 标准库进行了一些扩展。

```ad-must
title: glibc 和 C 标准库的关系

glibc 是 C 运行库，其提供了 C 标准规定的所有库函数，同时也提供了 C 语言的运行时环境中的一些基础服务，比如程序启动时的初始化工作、调用main函数等等。

类比来说，C 标准库是一个接口，glibc 是 Linux 下的一个实例，并添加了自己的函数。
```

gibc 的发布版本主要由两部分组成，一部分是头文件，比如 `stdio.h`、`stdlib.h` 等，它们往往位于 `usr/include`：另外一部分则是库的二进制文件部分。二进制部分主要的就是 C 语言标准库，它有静态和动态两个版本。动态的标准库我们及在本书的前面章节中碰到过了，它位于 `lib/libc.so.6`；而静态标准库位于 `usr/lib/libc.a`。事实上 glibc 除了 C 标准库之外，还有几个辅助程序运行的**运行库**，这几个文件可以称得上是真正的“运行库”。它们就是 `/usr/lib/crt1.o`、`usr/lib/cti.o` 和 `usr/lib/crtn.o`。是不是对这几个文件还有点印象呢？我们在第 2 章讲到静态库链接的时候已经碰到过它们了，虽然它们都很小，但这几个文件都是程序运行的最关键的文件。

## 3.1 glibc 启动文件

`crt1.o` 里面包含的就是程序的入口函数 `_start`，由它负责调用 `_libc_start_main` 初始化 libc 并且调用 main 函数进入真正的程序主体。实际上最初开始的时候它并不叫做 `crt1.o`，而是叫做 `crt.o`，包含了**基本的启动、退出代码**。由于当时有些链接器对链接时目标文件和库的顺序有依赖性，`crt.o` 这个文件必须被放在链接器命令行中的所有输入文件中的**第一个**，为了强调这一点，`crt.0` 被更名为 `crt0.o`，表示它是链接时输入的第一个文件。 ^rcq0ir

后来由于 C++ 的出现和 ELF 文件的改进，出来了必须在 `main()` 函数之前执行的全局/静态对象**构造**和必须在 `main()` 函数之后执行的全局/静态对象**析构**。为了满足类似的需求，运行库在每个目标文件中引入两个与初始化相关的段 `.init` 和 `.finit`。**运行库**会保证所有位于这两个段中的代码会先于/后于 `main()` 函数执行，所以用它们来实现全局构造和析构就是很自然的事情了。链接器在进行链接时，会把所有输入目标文件中的 `.init` 和 `.finit` 按照顺序收集起来，然后将它们合并成输出文件中的 `.init` 和 `.finit`。但是这两个输出的段中所包含的指令还需要一些辅助的代码来帮助它们启动（比如计算 GOT 之类的 #c ），于是引入了两个目标文件分别用来帮助实现初始化函数的 `crti.o` 和 `crtn.o`。

与此同时，为了支持新的库和可执行文件格式，`crt0.o` 也进行了升级，变成了 **`crt1.o`**。`crt0.o` 和 `crt1.o` 之间的区别是 `crt0.o` 为原始的，不支持 `.init` 和 `.finit` 的启动代码，而 `crt1.o` 是改进过后，支持 `.init` 和 `.finit` 的版本。**这一点我们从反汇编 `crt1.o` 可以看到，它向 libc 启动函数 `__libc_start_main()` 传递了两个函数指针 `__libc_csu_init` 和 `__libc_csu_fini`，这两个函数负责调用 `_init()` 和 `_finit()`**，我们在后面“C++全局构造和析构”的章节中还会详细分析。

为了方便运行库调用，最终输出文件中的 `.init` 和 `.finit` 两个段实际上分别包含的是 `_init()` 和 `_finit()` 这两个函数，我们在关于运行库初始化的部分也会看到这两个函数，并且在 C++全局构造和析构的章节中也会分析它们是如何实现全局构造和析构的。`crti.o` 和 `crtn.o` 这两个目标文件中包含的代码实际上是 `_init()` 和 `_finit()` 的开始和结尾部分，当这两个文件和其他目标文件安装顺序链接起来以后，刚好形成了两个完整的函数 `_init()` 和 `_finit()`。我们用 objdump 可以查看这两个文件的反汇编代码：

```

$ objdump -dr /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/crti.o

/usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/crti.o:     file format elf64-x86-64


Disassembly of section .init:

0000000000000000 <_init>:
   0:   f3 0f 1e fa             endbr64
   4:   48 83 ec 08             sub    $0x8,%rsp
   8:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax        # f <_init+0xf>
                        b: R_X86_64_REX_GOTPCRELX       __gmon_start__-0x4
   f:   48 85 c0                test   %rax,%rax
  12:   74 02                   je     16 <_init+0x16>
  14:   ff d0                   callq  *%rax

Disassembly of section .fini:

0000000000000000 <_fini>:
   0:   f3 0f 1e fa             endbr64
   4:   48 83 ec 08             sub    $0x8,%rsp

$ objdump -dr /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/crtn.o

/usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/crtn.o:     file format elf64-x86-64

Disassembly of section .init:

# 注意与 crti.o 的 .init 正好相反
0000000000000000 <.init>:
   0:   48 83 c4 08             add    $0x8,%rsp
   4:   c3                      retq

Disassembly of section .fini:

0000000000000000 <.fini>:
   0:   48 83 c4 08             add    $0x8,%rsp
   4:   c3                      retq
```

```ad-idea
title: 为什么gcc输出的文件路径是 /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/ 而不是 /usr/lib/x86_64-linux-gnu/

在Linux中，`/usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/` 实际上是一个相对路径，`..` 表示父目录，`../../../` 就表示向上回溯三级目录。这个路径最终会被解析成 `/usr/lib/x86_64-linux-gnu/`。使用这种相对路径的方式可以让路径在文件系统结构发生改变时保持正确。

那么，为什么GCC会输出这样看起来比较复杂的路径呢？这是因为在链接库文件时，GCC需要考虑库文件可能存放在不同的位置，包括系统目录、GCC自身的库目录以及用户指定的目录等。而这些目录之间的相对位置可能会因系统配置或GCC版本不同而有所差异。

例如，在这个路径中，`/usr/lib/gcc/x86_64-linux-gnu/9/` 可能是GCC自身的库文件目录，`/usr/lib/x86_64-linux-gnu/` 是系统的库文件目录。当GCC需要从系统的库文件目录加载库时，它会通过**相对路径**来引用，而不是硬编码绝对路径。这样可以在GCC库文件目录和系统库文件目录相对位置改变时仍能正确找到库文件。

总的来说，GCC使用这种看起来复杂的路径是为了在文件系统结构变化时能够正确地找到库文件。
```

```ad-sc
title: 解释下 crti.o 的反汇编代码

在你提供的反汇编代码中，包含了两个部分：`.init`和`.fini`。这两部分分别代表了初始化和结束，它们是由编译器自动生成的，并插入到生成的对象文件（在这个例子中是`crti.o`）中。`crti.o`（C Runtime Initialization Object）是C运行时库的一部分，它包含了程序开始和结束时需要运行的代码。

让我们来一部分一部分地看：

**.init段**

~~~asm
0000000000000000 <_init>:
   0:   f3 0f 1e fa             endbr64
   4:   48 83 ec 08             sub    $0x8,%rsp
   8:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax        # f <_init+0xf>
                        b: R_X86_64_REX_GOTPCRELX       __gmon_start__-0x4
   f:   48 85 c0                test   %rax,%rax
  12:   74 02                   je     16 <_init+0x16>
  14:   ff d0                   callq  *%rax
~~~

这部分代码在程序开始执行时运行，具体步骤如下：

1. `endbr64`：这是Intel Control-flow Enforcement Technology (CET)的一部分，用于防止不合法的间接跳转，提高程序的安全性。

2. `sub $0x8,%rsp`：从栈指针`%rsp`中减去8，即在栈上分配8字节的空间。这是为了保持栈的对齐。

3. `mov 0x0(%rip),%rax`：这是一个位置无关的代码（Position-Independent Code，PIC），它从`__gmon_start__`符号处读取一个地址并存放到寄存器`%rax`中。`__gmon_start__`是GNU gprof工具用来启动分析的函数。

4. `test %rax,%rax`：测试`%rax`的值是否为0。

5. `je 16 <_init+0x16>`：如果`%rax`的值为0（即`__gmon_start__`未定义或为空），则跳转到地址16处，跳过下面的`callq`指令。

6. `callq *%rax`：调用`%rax`寄存器中的地址指向的函数，即调用`__gmon_start__`。

**.fini段**

~~~asm
0000000000000000 <_fini>:
   0:   f3 0f 1e fa             endbr64
   4:   48 83 ec 08             sub    $0x8,%rsp
~~~

这部分代码在程序结束时运行。这段代码相对简单：

1. `endbr64`：同上。

2. `sub $0x8,%rsp`：同上。

以上就是你给出的反汇编

代码的解释。总的来说，这部分代码是为C程序的启动和结束提供支持的，包括调用`__gmon_start__`以启动GNU gprof分析（如果有的话）。
```

于是在最终链接完成之后，输出的目标文件中的 `.init` 段只包含了一个函数 `_init()`， 这个函数的开始部分来自于 `crti.o` 的 `.init` 段，结束部分来自于 `crtn.o` 的 `.init` 段。为了保证最终输出文件中 `.init` 和 `.finit` 的正确性，我们必须保证在链接时，`crti.o` 必须在用户目标文件和系统库之前，而`crtn.o` 必须在用户目标文件和系统库之后。链接器的输入文件顺序一般是：

```
ld crt1.o crti.o [user_objects] [system_libraries] crtn.o
```

```ad-sc
title: 使用 `gcc -Wl,--verbose a.o b.o main.o`

![vCcOLW](https://picture-suyifan.oss-cn-shenzhen.aliyuncs.com/uPic/vCcOLW.png)

中间许多许多 libc.a 的库函数

![n8CmPu](https://picture-suyifan.oss-cn-shenzhen.aliyuncs.com/uPic/n8CmPu.png)
```